{"version":3,"sources":["icon/right-thin-chevron-svgrepo-com.svg","helperFunctions/ensureNotUndefined.ts","GridNode/GridNode.tsx","Grid/Grid.tsx","NavBar/NavBar.tsx","helperFunctions/shortestPathAlgorithms/retrievePath.ts","helperFunctions/dataStructures/binaryHeap.ts","helperFunctions/shortestPathAlgorithms/singleTarget/dijkstra.ts","helperFunctions/shortestPathAlgorithms/singleTarget/aStar.ts","helperFunctions/shortestPathAlgorithms/multipleTarget/greedy.ts","helperFunctions/shortestPathAlgorithms/multipleTarget/bruteForce.ts","helperFunctions/shortestPathAlgorithms/allAlgorithms.ts","helperFunctions/shortestPathAlgorithms/singleTarget/dfs.ts","helperFunctions/shortestPathAlgorithms/singleTarget/bfs.ts","helperFunctions/shortestPathAlgorithms/singleTarget/twoEndedBfs.ts","helperFunctions/mazeGenerators/mazeGraph.ts","helperFunctions/constructGrid.ts","Wrapper/Wrapper.tsx","Visualizer/Visualizer.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","_objectWithoutProperties","excluded","sourceKeys","keys","indexOf","_objectWithoutPropertiesLoose","getOwnPropertySymbols","sourceSymbolKeys","propertyIsEnumerable","_ref2","createElement","_ref3","_ref4","_ref5","_ref6","_ref7","_ref8","_ref9","_ref10","_ref11","_ref12","_ref13","_ref14","_ref15","_ref16","_ref","svgRef","title","props","id","x","y","viewBox","style","enableBackground","xmlSpace","ref","fill","d","ForwardRef","forwardRef","ensure","argument","message","undefined","TypeError","getAddedClassName","neighbors","node","addedClassName","neighbor","neighborX","neighborY","distance","hasCheese","isShortestPath","isVisited","GridNode","React","memo","numberOfElementsPerRow","handleMouseDown","mouseState","handleMouseEnter","showNumbers","className","onMouseDown","e","onMouseEnter","role","aria-label","hasRat","successorPosition","isStart","find","prevProps","nextProps","Grid","grid","maze","pairGrid","map","row","rowLength","index","get","NavBar","children","NavButton","addedClassNames","startClassName","visualizingClassName","visualizedClassName","isVisualized","onClick","handleClick","text","NavItem","useState","open","setOpen","shouldGreyOut","event","document","addEventListener","dropDownMenu","getElementById","targetElement","parentNode","NavSlider","defaultValue","type","value","min","minValue","toString","max","maxValue","step","onChange","handleChange","DropDownMenu","left","height","DropDownItem","DropDownSlider","DropDownToggleSwich","checked","shouldShowWeights","retrievePath","predecessor","startNode","endNode","shortestPath","current","unshift","BinaryHeap","compare","content","element","push","bubbleUp","result","end","pop","sinkDown","n","parentN","Math","floor","parent","child2N","child1N","swap","dijkstraHelper","mazeGraph","oldTargetList","m","targetList","slice","distances","j","Number","MAX_SAFE_INTEGER","visited","pq","a","b","currentNode","targetNode","currentX","currentY","nextNode","currentDistance","visitedNode","remove","size","dijkstra","manhattanDistance","abs","greedy","currentStartNode","totalDistance","allVisitedAndPaths","path","filter","getTrueOptimalPath","optimalPath","actualPath","singleTargetAlgorithms","discovered","stack","discoveredNode","q","shift","dA","dB","successor","foundNode","middleNode","retrieveTwoEndedPath","multipleTargetsAlgorithms","newTargetList","distancesMatrix","getDistanceMatrix","maxCost","maxLength","branchAndBound","candidatePath","remainingTargets","currentCost","newRemainingTargets","forEach","targetNodeAndIndex","prevId","tgAndId","console","log","valueIndexPair","generateMazeGraph","columnLength","wallsDensity","mudDensity","mudWeight","MUD_WEIGHT","pairRow","Map","set","createMazeGraph","currentWallsCount","maxWallsOrMud","currentNonVisitedNeighbors","getNeighbors","neighborNode","random","maxWallsCount","randRow","randCol","getWalledOffNeighbors","randIndex","currentMud","maxMud","item","neighborNodeNeighbors","dir","includes","findCallback","constructGrid","numberOfRow","numberOfColumn","numberOfTargets","currentRow","piecesOfCheese","reconstructGrid","cheeseNum","Array","k","WrapperCSSTransition","handleEnter","nodeRef","useRef","CSSTransition","onEnter","isAppearing","el","offsetHeight","FIRST_END_NODE","firstGrid","firstStartNode","firstTargetList","firstpairGrid","Visualizer","gridRef","setGrid","setPairGrid","setIsVisualized","setMaze","setWallsDensity","setMudDensity","setMudWeight","setNumberOfTargets","shouldGenerateMaze","setShouldGenerateMaze","didMount","setShowNumbers","setStartNode","setTargetList","algoActiveMenu","setAlgoActiveMenu","singleTargetAlgorithm","setSingleTargetAlgorithm","multipleTargetsAlgorithm","setMultipleTargetsAlgorithm","setHeight","mouseIsPressed","setMouseIsPressed","draggedNode","visualizeSingleTargetAlgorithm","timeout","setTimeout","newGrid","getSuccessorPosition","handleAlgorithmChange","algorithmName","handleMenuChange","menuName","reinitializeGrid","newStartNode","useEffect","numberOfRows","cheeseToAdd","addPiecesOfCheese","onMouseUp","newPairGrid","newMaze","val","allVisitedAndPathsArray","currentTimeout","visualizeMultipleTargetsAlgorithm","in","unmountOnExit","classNames","appear","isTargetNode","oldStartNode","toggleNode","App","exact","component","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error"],"mappings":"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","file":"static/js/main.78559888.chunk.js","sourcesContent":["function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React from \"react\";\n\nvar _ref2 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar _ref3 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar _ref4 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar _ref5 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar _ref6 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar _ref7 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar _ref8 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar _ref9 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar _ref10 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar _ref11 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar _ref12 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar _ref13 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar _ref14 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar _ref15 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar _ref16 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar SvgRightThinChevronSvgrepoCom = function SvgRightThinChevronSvgrepoCom(_ref) {\n  var svgRef = _ref.svgRef,\n      title = _ref.title,\n      props = _objectWithoutProperties(_ref, [\"svgRef\", \"title\"]);\n\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    id: \"Capa_1\",\n    x: \"0px\",\n    y: \"0px\",\n    viewBox: \"0 0 185.343 185.343\",\n    style: {\n      enableBackground: \"new 0 0 185.343 185.343\"\n    },\n    xmlSpace: \"preserve\",\n    ref: svgRef\n  }, props), title ? /*#__PURE__*/React.createElement(\"title\", null, title) : null, /*#__PURE__*/React.createElement(\"g\", null, /*#__PURE__*/React.createElement(\"g\", null, /*#__PURE__*/React.createElement(\"path\", {\n    style: {\n      fill: \"#010002\"\n    },\n    d: \"M51.707,185.343c-2.741,0-5.493-1.044-7.593-3.149c-4.194-4.194-4.194-10.981,0-15.175 l74.352-74.347L44.114,18.32c-4.194-4.194-4.194-10.987,0-15.175c4.194-4.194,10.987-4.194,15.18,0l81.934,81.934 c4.194,4.194,4.194,10.987,0,15.175l-81.934,81.939C57.201,184.293,54.454,185.343,51.707,185.343z\"\n  }))), _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16);\n};\n\nvar ForwardRef = /*#__PURE__*/React.forwardRef(function (props, ref) {\n  return /*#__PURE__*/React.createElement(SvgRightThinChevronSvgrepoCom, _extends({\n    svgRef: ref\n  }, props));\n});\nexport default __webpack_public_path__ + \"static/media/right-thin-chevron-svgrepo-com.e4144d1e.svg\";\nexport { ForwardRef as ReactComponent };","// This function is here to ensure that a value is not undefined (especially when using arrays).\nexport function ensure<T>(\n  argument: T | undefined | null,\n  message: string = \"This value was promised to be there.\"\n): T {\n  if (argument === undefined || argument === null) {\n    throw new TypeError(message);\n  }\n  return argument;\n}\n","import React from \"react\";\nimport \"./GridNode.css\";\nimport { node } from \"../helperFunctions/usefulInterfaces\";\nimport { ReactComponent as ChevronRightIcon } from \"../icon/right-thin-chevron-svgrepo-com.svg\";\nimport { ensure } from \"../helperFunctions/ensureNotUndefined\";\n\ninterface Props {\n  numberOfElementsPerRow: number;\n  node: node;\n  neighbors: [[number, number], number][];\n  mouseState: boolean;\n  handleMouseDown: (currentNode: node) => void;\n  handleMouseEnter: (currentNode: node) => void;\n  showNumbers: boolean;\n}\n\nconst getAddedClassName: (\n  neighbors: [[number, number], number][],\n  node: node\n) => string = (neighbors, node) => {\n  let addedClassName: string = \"\";\n  for (let i = 0; i < neighbors.length; i++) {\n    let neighbor: [[number, number], number] = neighbors[i];\n    let neighborX = neighbor[0][0],\n      neighborY = neighbor[0][1],\n      distance: number = neighbor[1];\n    if (neighborX === node.x + 1)\n      addedClassName += distance === 1 ? \" no-wall-bottom\" : \" mud-bottom\";\n    if (neighborX === node.x - 1)\n      addedClassName += distance === 1 ? \" no-wall-top\" : \" mud-top\";\n    if (neighborY === node.y + 1)\n      addedClassName += distance === 1 ? \" no-wall-right\" : \" mud-right\";\n    if (neighborY === node.y - 1)\n      addedClassName += distance === 1 ? \" no-wall-left\" : \" mud-left\";\n  }\n  if (node.hasCheese) addedClassName += \" cheese\";\n  if (node.isShortestPath && node.isVisited)\n    addedClassName += \" shortest-path-node-being-visited\";\n  else {\n    if (node.isShortestPath) addedClassName += \" shortest-path-node\";\n    if (node.isVisited) addedClassName += \" visited-node\";\n  }\n  return addedClassName;\n};\n\n// This component represents a single Node in the grid rendered in the DOM\nexport const _GridNode: React.FC<Props> = ({\n  numberOfElementsPerRow,\n  node,\n  neighbors,\n  mouseState,\n  handleMouseDown,\n  handleMouseEnter,\n  showNumbers,\n}) => {\n  return (\n    <div\n      className={\"grid-node\" + getAddedClassName(neighbors, node)}\n      onMouseDown={(e) => handleMouseDown(node)}\n      onMouseEnter={(e) => handleMouseEnter(node)}\n    >\n      <span\n        role=\"img\"\n        aria-label=\"rat\"\n        className={node.hasRat ? \"content\" : \"no-content\"}\n      >\n        üêÄ\n      </span>\n      <span\n        role=\"img\"\n        aria-label=\"rat\"\n        className={node.hasCheese ? \"content\" : \"no-content\"}\n      >\n        üßÄ\n      </span>\n      <div className={\"svg-chevron \" + node.successorPosition}>\n        {node.isShortestPath && !(node.isStart || node.hasCheese) ? (\n          <ChevronRightIcon />\n        ) : (\n          <span></span>\n        )}\n      </div>\n      {showNumbers &&\n        neighbors.find((neighbor) => neighbor[0][0] === node.x + 1) &&\n        ensure(neighbors.find((neighbor) => neighbor[0][0] === node.x + 1))[1] >\n          1 && (\n          <span className=\"number-bottom\">\n            {\n              ensure(\n                neighbors.find((neighbor) => neighbor[0][0] === node.x + 1)\n              )[1]\n            }\n          </span>\n        )}\n      {showNumbers &&\n        neighbors.find((neighbor) => neighbor[0][1] === node.y + 1) &&\n        ensure(neighbors.find((neighbor) => neighbor[0][1] === node.y + 1))[1] >\n          1 && (\n          <span className=\"number-right\">\n            {\n              ensure(\n                neighbors.find((neighbor) => neighbor[0][1] === node.y + 1)\n              )[1]\n            }\n          </span>\n        )}\n    </div>\n  );\n};\n\nconst areEqual: (prevProps: Props, nextProps: Props) => boolean = (\n  prevProps,\n  nextProps\n) => {\n  return (\n    getAddedClassName(prevProps.neighbors, prevProps.node) ===\n      getAddedClassName(nextProps.neighbors, nextProps.node) &&\n    prevProps.node === nextProps.node &&\n    prevProps.mouseState === nextProps.mouseState &&\n    prevProps.showNumbers === nextProps.showNumbers\n  );\n};\n\nexport const GridNode = React.memo(_GridNode, areEqual);\n","import React from \"react\";\nimport { GridNode } from \"../GridNode/GridNode\";\nimport \"./Grid.css\";\nimport { node } from \"../helperFunctions/usefulInterfaces\";\nimport { ensure } from \"../helperFunctions/ensureNotUndefined\";\n\ninterface Props {\n  grid: node[][];\n  maze: Map<[number, number], [[number, number], number][]>;\n  pairGrid: [number, number][][];\n  mouseState: boolean;\n  handleMouseDown: (currentNode: node) => void;\n  handleMouseEnter: (currentNode: node) => void;\n  showNumbers: boolean;\n}\n\nexport const Grid: React.FC<Props> = ({\n  grid,\n  maze,\n  pairGrid,\n  mouseState,\n  handleMouseDown,\n  handleMouseEnter,\n  showNumbers,\n}) => {\n  // Renders the grid in the DOM thanks to the grid state in the App component\n  return (\n    <div className=\"grid\">\n      {grid.map((row, id) => {\n        let rowLength = row.length;\n        return (\n          <div className=\"row\" key={id}>\n            {row.map((node, index) => (\n              <GridNode\n                numberOfElementsPerRow={rowLength}\n                key={id + index * rowLength}\n                node={node}\n                neighbors={ensure(maze.get(pairGrid[node.x][node.y]))}\n                mouseState={mouseState}\n                handleMouseDown={handleMouseDown}\n                handleMouseEnter={handleMouseEnter}\n                showNumbers={showNumbers}\n              ></GridNode>\n            ))}\n          </div>\n        );\n      })}\n    </div>\n  );\n};\n","import React, { useState } from \"react\";\nimport \"./NavBar.css\";\n\nexport const NavBar: React.FC = (props) => {\n  return (\n    <nav className=\"navbar\">\n      <ul className=\"navbar-nav\">{props.children}</ul>\n    </nav>\n  );\n};\n\ninterface NavButtonProps {\n  text: string;\n  isVisualized: number;\n  className: string;\n  startClassName?: string;\n  visualizingClassName: string;\n  visualizedClassName: string;\n  handleClick: () => void;\n}\n\nexport const NavButton: React.FC<NavButtonProps> = (props) => {\n  const addedClassNames: string[] = [\n    props.startClassName ? props.startClassName : \"\",\n    props.visualizingClassName,\n    props.visualizedClassName,\n  ];\n\n  return (\n    <li\n      className={\n        \"nav-item \" +\n        addedClassNames[props.isVisualized] +\n        \" \" +\n        props.className\n      }\n      onClick={(e) => {\n        props.handleClick();\n      }}\n    >\n      <p>{props.text}</p>\n    </li>\n  );\n};\n\ninterface NavItemProps {\n  text: string;\n  id: string;\n  isVisualized: number;\n  shouldGreyOut: boolean;\n}\n\nexport const NavItem: React.FC<NavItemProps> = (props) => {\n  const [open, setOpen] = useState(false);\n\n  const handleClick: (e: any) => void = (event) => {\n    if (!props.shouldGreyOut || !props.isVisualized) setOpen(!open);\n    document.addEventListener(\"click\", (e) => {\n      const dropDownMenu = document.getElementById(props.id);\n      let targetElement = e.target as Element;\n\n      do {\n        if (targetElement === dropDownMenu) return;\n        targetElement = targetElement.parentNode as Element;\n      } while (targetElement);\n      setOpen(false);\n    });\n  };\n\n  return (\n    <li\n      id={props.id}\n      className={\n        \"nav-item\" +\n        (props.shouldGreyOut && props.isVisualized ? \" greyed-out\" : \"\")\n      }\n    >\n      <p className=\"icon-button\" onClick={handleClick}>\n        {props.text}\n      </p>\n      {open && props.children}\n    </li>\n  );\n};\n\ninterface NavSliderProps {\n  className: string;\n  minValue: number;\n  maxValue: number;\n  step: number;\n  defaultValue: number;\n  text: string;\n  handleChange: (event: any) => void;\n  isVisualized: number;\n  visualizingClassName: string;\n  visualizedClassName: string;\n}\n\nexport const NavSlider: React.FC<NavSliderProps> = (props) => {\n  return (\n    <div\n      className={\n        \"nav-slider nav-item \" +\n        props.className +\n        (props.isVisualized === 1 ? \" \" + props.visualizingClassName : \"\") +\n        (props.isVisualized === 2 ? \" \" + props.visualizedClassName : \"\")\n      }\n    >\n      <div className=\"nav-slider-item-text\">\n        <div>\n          <span>{props.text}</span>\n        </div>\n        <div className=\"nav-slider-value\">\n          <span>{props.defaultValue}</span>\n        </div>\n      </div>\n      <input\n        className=\"slider\"\n        type=\"range\"\n        value={props.defaultValue}\n        min={props.minValue.toString()}\n        max={props.maxValue.toString()}\n        step={props.step}\n        onChange={(e) => props.handleChange(e.target.value)}\n      ></input>\n    </div>\n  );\n};\n\ninterface DropDownMenu {\n  height?: number;\n  left?: boolean;\n}\n\nexport const DropDownMenu: React.FC<DropDownMenu> = (props) => {\n  return (\n    <div\n      className={\"dropdown\" + (props.left ? \" left\" : \"\")}\n      style={{ height: props.height }}\n    >\n      {props.children}\n    </div>\n  );\n};\n\ninterface DropDownAlgoProps {\n  leftIcon?: string;\n  rightIcon?: string;\n  handleClick: () => void;\n}\n\nexport const DropDownItem: React.FC<DropDownAlgoProps> = (props) => {\n  return (\n    <div\n      className=\"menu-item\"\n      onClick={(e) => {\n        props.handleClick();\n      }}\n    >\n      {props.children}\n    </div>\n  );\n};\n\ninterface DropDownSliderProps {\n  minValue: number;\n  maxValue: number;\n  step: number;\n  defaultValue: number;\n  text: string;\n  handleChange: (event: any) => void;\n}\n\nexport const DropDownSlider: React.FC<DropDownSliderProps> = (props) => {\n  return (\n    <div className=\"slider-item\">\n      <div className=\"slider-item-text\">\n        <div>\n          <span>{props.text}</span>\n        </div>\n        <div className=\"slider-value\">\n          <span>{props.defaultValue}</span>\n        </div>\n      </div>\n      <input\n        className=\"slider\"\n        type=\"range\"\n        value={props.defaultValue}\n        min={props.minValue.toString()}\n        max={props.maxValue.toString()}\n        step={props.step}\n        onChange={(e) => props.handleChange(e.target.value)}\n      ></input>\n    </div>\n  );\n};\n\ninterface DropDownToggleSwitchProps {\n  text: string;\n  shouldShowWeights: boolean;\n  handleChange: () => void;\n}\n\nexport const DropDownToggleSwich: React.FC<DropDownToggleSwitchProps> = (\n  props\n) => {\n  return (\n    <div className=\"menu-item switch-item\">\n      <span className=\"switch-text\">{props.text}</span>\n      <label className=\"switch\">\n        <input\n          type=\"checkbox\"\n          checked={props.shouldShowWeights}\n          onChange={props.handleChange}\n        />\n        <span className=\"switch-slider round\"></span>\n      </label>\n    </div>\n  );\n};\n","import { node } from \"../usefulInterfaces\";\n\nexport const retrievePath: (\n  predecessor: node[],\n  startNode: node,\n  endNode: node\n) => node[] = (predecessor, startNode, endNode) => {\n  let shortestPath = [endNode];\n  let current: node = endNode;\n  while (current.x !== startNode.x || current.y !== startNode.y) {\n    current = predecessor[current.id];\n    shortestPath.unshift(current);\n  }\n\n  return shortestPath;\n};\n\nexport const retrieveTwoEndedPath: (\n  predecessor: node[],\n  successor: node[],\n  middleNode: node,\n  startNode: node,\n  endNode: node\n) => node[] = (predecessor, successor, middleNode, startNode, endNode) => {\n  let shortestPath = [middleNode];\n  let current: node = middleNode;\n  while (current.x !== startNode.x || current.y !== startNode.y) {\n    current = predecessor[current.id];\n    shortestPath.unshift(current);\n  }\n  current = middleNode;\n  while (current.x !== endNode.x || current.y !== endNode.y) {\n    current = successor[current.id];\n    shortestPath.push(current);\n  }\n  return shortestPath;\n};\n","import { ensure } from \"../ensureNotUndefined\";\n\nexport class BinaryHeap<T> {\n  content: ([T, number] | undefined)[];\n  compare: (a: [T, number], b: [T, number]) => boolean;\n  index: number;\n\n  constructor(compare: (a: [T, number], b: [T, number]) => boolean) {\n    this.content = [];\n    this.index = 1;\n    this.compare = compare;\n  }\n\n  push(element: T) {\n    this.content.push([element, this.index++]);\n    this.bubbleUp(this.content.length - 1);\n  }\n\n  pop(): T | undefined {\n    let result: [T, number] = ensure(this.content[0]);\n    let end: [T, number] | undefined = this.content.pop();\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.sinkDown(0);\n    }\n    return ensure(result)[0];\n  }\n\n  remove(node: T) {\n    let length: number = this.content.length;\n    // To remove a value, we must search through the array to find\n    // it.\n    for (let i: number = 0; i < length; i++) {\n      if (ensure(this.content[i])[0] !== node) continue;\n      // When it is found, the process seen in 'pop' is repeated\n      // to fill up the hole.\n      let end: [T, number] | undefined = this.content.pop();\n      // If the element we popped was the one we needed to remove,\n      // we're done.\n      if (i === length - 1) break;\n      // Otherwise, we replace the removed element with the popped\n      // one, and allow it to float up or sink down as appropriate.\n      this.content[i] = end;\n      this.bubbleUp(i);\n      this.sinkDown(i);\n      break;\n    }\n  }\n\n  size() {\n    return this.content.length;\n  }\n\n  private bubbleUp(n: number) {\n    // Fetch the element that has to be moved.\n    let element: [T, number] = ensure(this.content[n]);\n    // When at 0, an element can not go up any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      let parentN: number = Math.floor((n + 1) / 2) - 1,\n        parent: [T, number] = ensure(this.content[parentN]);\n      // If the parent has a lesser score, things are in order and we\n      // are done.\n      // if (\n      //   score > this.scoreFunction(ensure(parent)[0]) ||\n      //   (score === this.scoreFunction(ensure(parent)[0]) &&\n      //     ensure(element)[1] > ensure(parent)[1])\n      // )\n      //   break;\n      if (this.compare(parent, element)) break;\n\n      // Otherwise, swap the parent with the current element and\n      // continue.\n      this.content[parentN] = element;\n      this.content[n] = parent;\n      n = parentN;\n    }\n  }\n\n  private sinkDown(n: number) {\n    // Look up the target element and its score.\n    let length: number = this.content.length,\n      element: [T, number] = ensure(this.content[n]);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      let child2N: number = (n + 1) * 2,\n        child1N: number = child2N - 1;\n      let swap: number = n;\n      // This is used to store the new position of the element, if any.\n      // If the first child exists (is inside the array)...\n      if (\n        child1N < length &&\n        this.compare(ensure(this.content[child1N]), element)\n      )\n        swap = child1N;\n      if (\n        child2N < length &&\n        this.compare(ensure(this.content[child2N]), ensure(this.content[swap]))\n      )\n        swap = child2N;\n\n      // If the order is good, we exit the loop\n      if (swap === n) break;\n\n      // Otherwise, swap and continue.\n      this.content[n] = this.content[swap];\n      this.content[swap] = element;\n      n = swap;\n    }\n  }\n}\n","import { node } from \"../../usefulInterfaces\";\nimport { BinaryHeap } from \"../../dataStructures/binaryHeap\";\nimport { retrievePath } from \"../retrievePath\";\nimport { ensure } from \"../../ensureNotUndefined\";\n\nexport const dijkstraHelper: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetList: node[]\n) => [node[], node[], node, number] = (\n  grid,\n  pairGrid,\n  mazeGraph,\n  startNode,\n  oldTargetList\n) => {\n  const m = grid.length,\n    n = grid[0].length;\n  const targetList: node[] = oldTargetList.slice();\n  // Initialize the distances array\n  const distances: number[][] = [];\n  for (let i: number = 0; i < m; i++) {\n    distances.push([]);\n    for (let j: number = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER - 1);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  for (let i: number = 0; i < m * n; i++) {\n    predecessor.push(startNode);\n  }\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  //   Initialize the Binary Heap\n  let pq: BinaryHeap<node> = new BinaryHeap<node>(\n    (a: [node, number], b: [node, number]) => {\n      if (distances[a[0].x][a[0].y] !== distances[b[0].x][b[0].y]) {\n        return distances[a[0].x][a[0].y] < distances[b[0].x][b[0].y];\n      }\n      return a[1] < b[1];\n    }\n  );\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode: node = ensure(pq.pop());\n\n    // add the current node to the visited nodes\n    visited.push(currentNode);\n\n    // If we found the endNode, return the shortest path to it\n    if (targetList.find((targetNode) => targetNode === currentNode)) {\n      // Retrieve the shortest path\n      const shortestPath = retrievePath(predecessor, startNode, currentNode);\n      return [\n        visited,\n        shortestPath,\n        currentNode,\n        distances[currentNode.x][currentNode.y],\n      ];\n    }\n\n    // Get the coordinates of the nodes\n    let currentX: number = currentNode.x;\n    let currentY: number = currentNode.y;\n\n    // Iterate the neighbors of the node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentX][currentY])\n    )) {\n      // Get the coordinates of the neighbor node\n      let neighborX: number = neighbor[0][0],\n        neighborY: number = neighbor[0][1];\n\n      // Check if the coordinates are valid\n      if (neighborX < 0 || neighborX >= m || neighborY < 0 || neighborY >= n)\n        continue;\n\n      let nextNode: node = grid[neighborX][neighborY];\n\n      // Calculate the distance between the current node and the next node\n      // To Do: take into account the weight of the path\n      let currentDistance: number = distances[currentX][currentY] + neighbor[1];\n\n      // If the distance is less than the distance in the array distances,\n      // change it and change the predecessor of the next node to be the current one\n      if (currentDistance < distances[neighborX][neighborY]) {\n        predecessor[nextNode.id] = currentNode;\n        distances[neighborX][neighborY] = currentDistance;\n      }\n\n      // If the node is not yet visited, remove it from the heap and\n      // put it back in with its new distance as the score function\n      if (!visited.find((visitedNode) => visitedNode === nextNode)) {\n        pq.remove(nextNode);\n        pq.push(nextNode);\n      }\n    }\n  }\n  return [visited, [], startNode, 0];\n};\n\nexport const getDistanceMatrix: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  targetList: node[]\n) => number[][] = (grid, pairGrid, mazeGraph, targetList) => {\n  const result: number[][] = [];\n  for (let i: number = 0; i < targetList.length; i++) {\n    result.push([]);\n    for (let j: number = 0; j < targetList.length; j++) {\n      const distance = dijkstraHelper(\n        grid,\n        pairGrid,\n        mazeGraph,\n        targetList[i],\n        targetList.filter((targetNode: node) => targetNode === targetList[j])\n      )[3];\n      if (i !== j) result[i].push(distance);\n      else result[i].push(0);\n    }\n  }\n\n  return result;\n};\n\nexport const dijkstra: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetList: node[]\n) => [node[], node[]] = (grid, pairGrid, mazeGraph, startNode, targetList) => {\n  const [visited, path] = dijkstraHelper(\n    grid,\n    pairGrid,\n    mazeGraph,\n    startNode,\n    targetList\n  );\n  return [visited, path];\n};\n","import { node } from \"../../usefulInterfaces\";\nimport { BinaryHeap } from \"../../dataStructures/binaryHeap\";\nimport { retrievePath } from \"../retrievePath\";\nimport { ensure } from \"../../ensureNotUndefined\";\n\nexport const aStar: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetList: node[]\n) => [node[], node[]] = (grid, pairGrid, mazeGraph, startNode, targetList) => {\n  const m = grid.length,\n    n = grid[0].length;\n  const endNode: node = targetList[0];\n\n  // Initialize the distances array\n  const distances: number[][] = [];\n  for (let i: number = 0; i < m; i++) {\n    distances.push([]);\n    for (let j: number = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  for (let i: number = 0; i < m * n; i++) {\n    predecessor.push(startNode);\n  }\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  //   Initialize the Binary Heap\n  let pq: BinaryHeap<node> = new BinaryHeap<node>(\n    (a: [node, number], b: [node, number]) => {\n      let dA: number = manhattanDistance(a[0], endNode),\n        dB: number = manhattanDistance(b[0], endNode);\n      if (distances[a[0].x][a[0].y] + dA !== distances[b[0].x][b[0].y] + dB) {\n        return distances[a[0].x][a[0].y] + dA < distances[b[0].x][b[0].y] + dB;\n      }\n      return a[1] < b[1];\n    }\n  );\n\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode: node = ensure(pq.pop());\n\n    // add the current node to the visited nodes\n    visited.push(currentNode);\n\n    // If we found the endNode, return the shortest path to it\n    if (currentNode === endNode) {\n      // Retrieve the shortest path\n      const shortestPath = retrievePath(predecessor, startNode, endNode);\n      return [visited, shortestPath];\n    }\n\n    // Get the coordinates of the nodes\n    let currentX: number = currentNode.x;\n    let currentY: number = currentNode.y;\n\n    // Iterate the neighbors of the node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentX][currentY])\n    )) {\n      // Get the coordinates of the neighbor node\n      let neighborX: number = neighbor[0][0],\n        neighborY: number = neighbor[0][1];\n\n      // Check if the coordinates are valid\n      if (neighborX < 0 || neighborX >= m || neighborY < 0 || neighborY >= n)\n        continue;\n\n      let nextNode: node = grid[neighborX][neighborY];\n\n      // Calculate the distance between the current node and the next node\n      let currentDistance: number = distances[currentX][currentY] + neighbor[1];\n\n      // If the distance is less than the distance in the array distances,\n      // change it and change the predecessor of the next node to be the current one\n      if (currentDistance < distances[neighborX][neighborY]) {\n        predecessor[nextNode.id] = currentNode;\n        distances[neighborX][neighborY] = currentDistance;\n      }\n\n      // If the node is not yet visited, remove it from the heap and\n      // put it back in with its new distance as the score function\n      if (!visited.find((visitedNode) => visitedNode === nextNode)) {\n        pq.remove(nextNode);\n        pq.push(nextNode);\n      }\n    }\n  }\n  return [visited, []];\n};\n\nconst manhattanDistance: (a: node, b: node) => number = (a, b) => {\n  return Math.abs(b.x - a.x) + Math.abs(b.y - a.y);\n};\n","import { node } from \"../../usefulInterfaces\";\nimport { dijkstraHelper } from \"../singleTarget/dijkstra\";\n\nexport const greedy: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetList: node[]\n) => [[node[], node[]][], number] = (\n  grid,\n  pairGrid,\n  mazeGraph,\n  startNode,\n  targetList\n) => {\n  let currentStartNode: node = startNode,\n    totalDistance: number = 0;\n  let allVisitedAndPaths: [node[], node[]][] = [];\n  while (targetList.length > 0) {\n    let [visited, path, endNode, distance] = dijkstraHelper(\n      grid,\n      pairGrid,\n      mazeGraph,\n      currentStartNode,\n      targetList.slice()\n    );\n    totalDistance += distance;\n    targetList = targetList.filter((targetNode) => targetNode !== endNode);\n    currentStartNode = endNode;\n    allVisitedAndPaths.push([visited, path]);\n  }\n  return [allVisitedAndPaths, totalDistance];\n};\n","import { node } from \"../../usefulInterfaces\";\nimport { dijkstra, getDistanceMatrix } from \"../singleTarget/dijkstra\";\nimport { greedy } from \"./greedy\";\n\nexport const bruteForceTSP: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetList: node[]\n) => [[node[], node[]][], number] = (\n  grid,\n  pairGrid,\n  mazeGraph,\n  startNode,\n  targetList\n) => {\n  const newTargetList: node[] = targetList.slice();\n  newTargetList.unshift(startNode);\n  const distancesMatrix: number[][] = getDistanceMatrix(\n    grid,\n    pairGrid,\n    mazeGraph,\n    newTargetList\n  );\n  let path: [node, number][] = [[startNode, 0]];\n  let optimalPath: [node, number][] = [];\n\n  let maxCost: number = greedy(\n    grid,\n    pairGrid,\n    mazeGraph,\n    startNode,\n    targetList\n  )[1];\n  const maxLength: number = targetList.length + 1;\n  const bnbtargets: [node, number][] = targetList.map((targetNode, i) => [\n    targetNode,\n    i + 1,\n  ]);\n\n  const branchAndBound: (\n    candidatePath: [node, number][],\n    remainingTargets: [node, number][],\n    currentCost: number\n  ) => void = (candidatePath, remainingTargets, currentCost) => {\n    if (candidatePath.length === maxLength) {\n      if (currentCost > maxCost) return;\n      maxCost = currentCost;\n      optimalPath = candidatePath;\n      return;\n    }\n    const newRemainingTargets: [node, number][] = remainingTargets.slice();\n    remainingTargets.forEach((targetNodeAndIndex) => {\n      let prevId: number = candidatePath[candidatePath.length - 1][1];\n      candidatePath.push(targetNodeAndIndex);\n      branchAndBound(\n        candidatePath.slice(),\n        newRemainingTargets.filter(\n          (tgAndId) => tgAndId[1] !== targetNodeAndIndex[1]\n        ),\n        currentCost + distancesMatrix[prevId][targetNodeAndIndex[1]]\n      );\n      candidatePath.pop();\n    });\n  };\n  branchAndBound(path, bnbtargets, 0);\n  console.log(optimalPath);\n  return [\n    getTrueOptimalPath(\n      grid,\n      pairGrid,\n      mazeGraph,\n      optimalPath.map((valueIndexPair) => valueIndexPair[0])\n    ),\n    maxCost,\n  ];\n};\n\nconst getTrueOptimalPath: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  optimalPath: node[]\n) => [node[], node[]][] = (grid, pairGrid, mazeGraph, optimalPath) => {\n  let actualPath: [node[], node[]][] = [];\n  for (let i: number = 0; i < optimalPath.length - 1; i++) {\n    let path = dijkstra(grid, pairGrid, mazeGraph, optimalPath[i], [\n      optimalPath[i + 1],\n    ])[1];\n    actualPath.push([[], path.slice()]);\n  }\n  return actualPath;\n};\n","import { node } from \"../usefulInterfaces\";\nimport { dfs } from \"./singleTarget/dfs\";\nimport { bfs } from \"./singleTarget/bfs\";\nimport { dijkstra } from \"./singleTarget/dijkstra\";\nimport { aStar } from \"./singleTarget/aStar\";\nimport { greedy } from \"./multipleTarget/greedy\";\nimport { bruteForceTSP } from \"./multipleTarget/bruteForce\";\nimport { twoEndedBfs } from \"./singleTarget/twoEndedBfs\";\n\nexport const singleTargetAlgorithms: {\n  [key: string]: (\n    grid: node[][],\n    pairGrid: [number, number][][],\n    mazeGraph: Map<[number, number], [[number, number], number][]>,\n    startNode: node,\n    targetList: node[]\n  ) => [node[], node[]];\n} = {\n  \"Depth First Search\": dfs,\n  \"Breadth First Search\": bfs,\n  \"Dijkstra's algorithm\": dijkstra,\n  \"A* algorithm\": aStar,\n  \"Meet in the Middle BFS\": twoEndedBfs,\n};\n\nexport const multipleTargetsAlgorithms: {\n  [key: string]: (\n    grid: node[][],\n    pairGrid: [number, number][][],\n    mazeGraph: Map<[number, number], [[number, number], number][]>,\n    startNode: node,\n    targetList: node[]\n  ) => [[node[], node[]][], number];\n} = {\n  \"Nearest Neighbors Heuristic\": greedy,\n  \"Brute Force Algorithm\": bruteForceTSP,\n};\n","import { node } from \"../../usefulInterfaces\";\nimport { retrievePath } from \"../retrievePath\";\nimport { ensure } from \"../../ensureNotUndefined\";\n\nexport const dfs: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetList: node[]\n) => [node[], node[]] = (grid, pairGrid, mazeGraph, startNode, targetList) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  // Discovered array\n  let discovered: node[] = [startNode];\n\n  // Initialize the stack\n  let stack: node[] = [startNode];\n\n  // While the stack is not empty\n  while (stack.length > 0) {\n    // Get the element in front of the stack\n    let currentNode: node = ensure(stack.pop());\n\n    if (visited.find((visitedNode) => visitedNode === currentNode)) continue;\n\n    // Put the currentNode node in the visited set\n    visited.push(currentNode);\n\n    // If we found the end node, return the path to it\n    if (targetList.find((targetNode) => currentNode)) {\n      // Retrieve the shortest path\n      const shortestPath = retrievePath(predecessor, startNode, currentNode);\n      return [visited, shortestPath];\n    }\n\n    // iterate through the neighbors of the currentNode node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentNode.x][currentNode.y])\n    )) {\n      // Get the coordinates of the neighbor node\n      let neighborX: number = neighbor[0][0],\n        neighborY: number = neighbor[0][1];\n\n      // Check if the node is on the board\n      if (\n        neighborX < 0 ||\n        neighborX >= m ||\n        neighborY < 0 ||\n        neighborY >= n ||\n        discovered.find(\n          (discoveredNode) => discoveredNode === grid[neighborX][neighborY]\n        )\n      )\n        continue;\n\n      // Get the node in the grid\n      let nextNode: node = grid[neighborX][neighborY];\n\n      // update the predecessor array\n      predecessor[nextNode.id] = currentNode;\n\n      // Add the node to the discovered array\n      discovered.push(nextNode);\n\n      // Push the nextNode to the stack\n      stack.push(nextNode);\n    }\n  }\n\n  return [visited, []];\n};\n","import { node } from \"../../usefulInterfaces\";\nimport { retrievePath } from \"../retrievePath\";\nimport { ensure } from \"../../ensureNotUndefined\";\n\nexport const bfs: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetList: node[]\n) => [node[], node[]] = (grid, pairGrid, mazeGraph, startNode, targetList) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  // Initialize the discovered array\n  let discovered: node[] = [startNode];\n\n  // Initialize the Queue TODO: IMPLEMENT A BETTER VERSION OF THE QUEUE WITH O(1) OPERATIONS\n  let q: node[] = [startNode];\n\n  // While the queue is not empty\n  while (q.length > 0) {\n    // Get the element in front of the queue\n    let currentNode: node = ensure(q.shift());\n\n    if (visited.find((visitedNode) => visitedNode === currentNode)) continue;\n\n    // Put the currentNode node in the visited set\n    visited.push(currentNode);\n\n    // If we found the end node, return the path to it\n    if (targetList.find((targetNode) => currentNode === targetNode)) {\n      // Retrieve the shortest path\n      const shortestPath = retrievePath(predecessor, startNode, currentNode);\n      return [visited, shortestPath];\n    }\n\n    // iterate through the neighbors of the currentNode node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentNode.x][currentNode.y])\n    )) {\n      // Get the coordinates of the neighbor node\n      let neighborX: number = neighbor[0][0],\n        neighborY: number = neighbor[0][1];\n\n      if (\n        neighborX < 0 ||\n        neighborX >= m ||\n        neighborY < 0 ||\n        neighborY >= n ||\n        discovered.find(\n          (discoveredNode) => discoveredNode === grid[neighborX][neighborY]\n        )\n      )\n        continue;\n\n      // Get the node in the grid\n      let nextNode: node = grid[neighborX][neighborY];\n\n      // update the predecessor array\n      predecessor[nextNode.id] = currentNode;\n\n      // Add the node to the visited nodes\n      discovered.push(nextNode);\n\n      // Push the next node to the queue\n      q.push(nextNode);\n    }\n  }\n\n  return [visited, []];\n};\n","import { node } from \"../../usefulInterfaces\";\nimport { retrieveTwoEndedPath } from \"../retrievePath\";\nimport { ensure } from \"../../ensureNotUndefined\";\n\nexport const twoEndedBfs: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetList: node[]\n) => [node[], node[]] = (grid, pairGrid, mazeGraph, startNode, targetList) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  for (let i: number = 0; i < m * n; i++) {\n    predecessor.push(startNode);\n  }\n  predecessor[startNode.id] = startNode;\n\n  const successor: node[] = [];\n  for (let i: number = 0; i < m * n; i++) {\n    successor.push(targetList[0]);\n  }\n  successor[targetList[0].id] = targetList[0];\n\n  const source: node[] = [];\n  for (let i: number = 0; i < m * n; i++) {\n    source.push(targetList[0]);\n  }\n  source[startNode.id] = startNode;\n  source[targetList[0].id] = targetList[0];\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  // Initialize the discovered array\n  let discovered: node[] = [startNode, targetList[0]];\n\n  // Initialize the Queue TODO: IMPLEMENT A BETTER VERSION OF THE QUEUE WITH O(1) OPERATIONS\n  let q: node[] = [startNode, targetList[0]];\n\n  // While the queue is not empty\n  while (q.length > 0) {\n    // Get the element in front of the queue\n    let currentNode: node = ensure(q.shift());\n\n    if (visited.find((visitedNode) => visitedNode === currentNode)) continue;\n\n    // Put the currentNode node in the visited set\n    visited.push(currentNode);\n\n    // iterate through the neighbors of the currentNode node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentNode.x][currentNode.y])\n    )) {\n      // Get the coordinates of the neighbor node\n      let neighborX: number = neighbor[0][0],\n        neighborY: number = neighbor[0][1];\n\n      if (neighborX < 0 || neighborX >= m || neighborY < 0 || neighborY >= n)\n        continue;\n\n      // Get the node in the grid\n      let nextNode: node = grid[neighborX][neighborY];\n\n      // Store the result of the find function for later\n      const foundNode: node | undefined = visited.find(\n        (visitedNode) => visitedNode === nextNode\n      );\n\n      // If we found the end node, return the path to it\n      if (foundNode && source[currentNode.id] !== source[foundNode.id]) {\n        if (source[currentNode.id] === startNode)\n          predecessor[nextNode.id] = currentNode;\n        else successor[nextNode.id] = currentNode;\n        // Retrieve the shortest path\n        const shortestPath = retrieveTwoEndedPath(\n          predecessor,\n          successor,\n          nextNode,\n          startNode,\n          targetList[0]\n        );\n        return [visited, shortestPath];\n      }\n\n      if (\n        discovered.find(\n          (discoveredNode) => discoveredNode === grid[neighborX][neighborY]\n        )\n      )\n        continue;\n\n      source[nextNode.id] = source[currentNode.id];\n\n      if (source[currentNode.id] === startNode) {\n        // update the predecessor array\n        predecessor[nextNode.id] = currentNode;\n      } else {\n        successor[nextNode.id] = currentNode;\n      }\n\n      // Add the node to the visited nodes\n      discovered.push(nextNode);\n\n      // Push the next node to the queue\n      q.push(nextNode);\n    }\n  }\n\n  return [visited, []];\n};\n","import { ensure } from \"../ensureNotUndefined\";\nimport { node } from \"../usefulInterfaces\";\n\nconst createMazeGraph: (\n  rowLength: number,\n  columnLength: number,\n  grid: node[][]\n) => [\n  [number, number][][],\n  Map<[number, number], [[number, number], number][]>\n] = (rowLength, columnLength, grid) => {\n  let pairGrid: [number, number][][] = [];\n  for (let i: number = 0; i < columnLength; i++) {\n    let pairRow: [number, number][] = [];\n    for (let j: number = 0; j < rowLength; j++) {\n      let currentNode: node = grid[i][j];\n      pairRow.push([currentNode.x, currentNode.y]);\n    }\n    pairGrid.push(pairRow);\n  }\n\n  // Create the maze graph\n  let mazeGraph: Map<\n    [number, number],\n    [[number, number], number][]\n  > = new Map();\n  for (let i: number = 0; i < columnLength; i++) {\n    for (let j: number = 0; j < rowLength; j++) {\n      mazeGraph.set(pairGrid[i][j], []);\n    }\n  }\n\n  return [pairGrid, mazeGraph];\n};\n\nexport const createEmptyMazeGraph: (\n  rowLength: number,\n  columnLength: number,\n  grid: node[][]\n) => [[number, number][][], Map<[number, number], [number, number][]>] = (\n  rowLength,\n  columnLength,\n  grid\n) => {\n  let pairGrid: [number, number][][] = [];\n  for (let i: number = 0; i < columnLength; i++) {\n    let pairRow: [number, number][] = [];\n    for (let j: number = 0; j < rowLength; j++) {\n      let currentNode: node = grid[i][j];\n      pairRow.push([currentNode.x, currentNode.y]);\n    }\n    pairGrid.push(pairRow);\n  }\n  // Create the maze graph\n  let mazeGraph: Map<[number, number], [number, number][]> = new Map();\n  for (let i: number = 0; i < columnLength; i++) {\n    for (let j: number = 0; j < rowLength; j++) {\n      let neighbors: [number, number][] = getNeighborsEmpty(\n        pairGrid,\n        [i, j],\n        columnLength,\n        rowLength\n      );\n\n      mazeGraph.set(pairGrid[i][j], neighbors);\n    }\n  }\n  return [pairGrid, mazeGraph];\n};\n\nexport const generateMazeGraph: (\n  rowLength: number,\n  columnLength: number,\n  grid: node[][],\n  wallsDensity: number,\n  mudDendity: number,\n  mudWeigth: number\n) => [\n  [number, number][][],\n  Map<[number, number], [[number, number], number][]>\n] = (rowLength, columnLength, grid, wallsDensity, mudDensity, mudWeight) => {\n  const MUD_WEIGHT = mudWeight;\n\n  let [pairGrid, mazeGraph]: [\n    [number, number][][],\n    Map<[number, number], [[number, number], number][]>\n  ] = createMazeGraph(rowLength, columnLength, grid);\n\n  let currentWallsCount: number =\n      2 * (rowLength - 1) * (columnLength - 1) + rowLength + columnLength - 2,\n    maxWallsOrMud = currentWallsCount;\n\n  // I. Generate a maze where each cells is reachable (with a DFS)\n\n  // 1. Choose the initial cell, mark it as visited and push it to the stack\n  let startNode: [number, number] = pairGrid[0][0];\n  let stack: [number, number][] = [startNode];\n  let visited: [number, number][] = [startNode];\n\n  // 2. While the stack is not empty\n  while (stack.length > 0) {\n    // 1. Pop a cell from the stack and make it a current cell\n    let currentNode: [number, number] = ensure(stack.pop());\n    let currentNonVisitedNeighbors: [number, number][] = getNeighbors(\n      pairGrid,\n      currentNode,\n      rowLength,\n      columnLength,\n      visited\n    );\n    // 2. If the current cell has any neighbours which have not been visited\n    if (currentNonVisitedNeighbors.length > 0) {\n      // 1. Push the current cell to the stack\n      stack.push(currentNode);\n\n      // 2. Choose one of the unvisited neighbours\n      let randIndex: number = Math.floor(\n        Math.random() * currentNonVisitedNeighbors.length\n      );\n      let neighborNode: [number, number] =\n        currentNonVisitedNeighbors[randIndex];\n\n      // 3. Remove the wall between the current cell and the chosen cell\n      let currentNodeNeighbors: [[number, number], number][] = ensure(\n        mazeGraph.get(currentNode)\n      );\n      currentNodeNeighbors.push([neighborNode, 1]);\n\n      let neighborNodeNeighbors: [[number, number], number][] = ensure(\n        mazeGraph.get(neighborNode)\n      );\n      neighborNodeNeighbors.push([currentNode, 1]);\n\n      // 4. Mark the ch// mazeGraph.set(neighborNode, neighborNodeNeighbors);osen cell as visited and push it to the stack\n      visited.push(neighborNode);\n      stack.push(neighborNode);\n\n      // 5. Remove 1 from the currentWallsCount\n      currentWallsCount--;\n    }\n  }\n\n  // II. Remove walls until the desired density is achieved\n  let maxWallsCount: number = currentWallsCount;\n  while (currentWallsCount * (1 / maxWallsCount) > wallsDensity) {\n    // 1. Choose a node randomly\n    let randRow: number = Math.floor(Math.random() * rowLength);\n    let randCol: number = Math.floor(Math.random() * columnLength);\n    let currentNode: [number, number] = pairGrid[randCol][randRow];\n\n    // 2. Get the cells with a wall with the current cell\n    let neighbors: [number, number][] = getWalledOffNeighbors(\n      pairGrid,\n      currentNode,\n      rowLength,\n      columnLength,\n      mazeGraph\n    );\n\n    if (neighbors.length > 0) {\n      // 3. Choose one of the cells with a wall\n      let randIndex: number = Math.floor(Math.random() * neighbors.length);\n      let neighborNode: [number, number] =\n        pairGrid[neighbors[randIndex][0]][neighbors[randIndex][1]];\n\n      // 4. Remove the wall between the 2 cells\n      let currentNodeNeighbors: [[number, number], number][] = ensure(\n        mazeGraph.get(currentNode)\n      );\n      currentNodeNeighbors.push([neighborNode, 1]);\n\n      let neighborNodeNeighbors: [[number, number], number][] = ensure(\n        mazeGraph.get(neighborNode)\n      );\n      neighborNodeNeighbors.push([currentNode, 1]);\n\n      currentWallsCount--;\n    }\n  }\n\n  // III. Add mud to the graph until we get the desired mud density\n  let currentMud: number = 0,\n    maxMud: number = maxWallsOrMud - currentWallsCount;\n  while (currentMud * (1 / maxMud) < mudDensity) {\n    // 1. Choose a node randomly\n    let randRow: number = Math.floor(Math.random() * rowLength);\n    let randCol: number = Math.floor(Math.random() * columnLength);\n    let currentNode: [number, number] = pairGrid[randCol][randRow];\n\n    // 2. Get the neighbors than have no mud\n    let neighbors: [[number, number], number][] = ensure(\n      mazeGraph.get(currentNode)\n    ).filter((item: [[number, number], number]) => item[1] === 1);\n\n    if (neighbors.length > 0) {\n      // 3. Get a random neighbor\n      let randIndex: number = Math.floor(Math.random() * neighbors.length);\n      let neighborNode: [number, number] =\n        pairGrid[neighbors[randIndex][0][0]][neighbors[randIndex][0][1]];\n\n      neighbors[randIndex][1] = MUD_WEIGHT;\n\n      let neighborNodeNeighbors: [[number, number], number][] = ensure(\n        mazeGraph.get(neighborNode)\n      );\n      let currentNodeAndDistance: [[number, number], number] = ensure(\n        neighborNodeNeighbors.find(\n          (item: [[number, number], number]) => item[0] === currentNode\n        )\n      );\n      currentNodeAndDistance[1] = MUD_WEIGHT;\n      currentMud++;\n    }\n  }\n  return [pairGrid, mazeGraph];\n};\n\nconst getNeighbors: (\n  grid: [number, number][][],\n  currentNode: [number, number],\n  rowLength: number,\n  columnLength: number,\n  visited: [number, number][]\n) => [number, number][] = (\n  pairGrid,\n  currentNode,\n  rowLength,\n  columnLength,\n  visited\n) => {\n  const directions = [\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n    [0, 1],\n  ];\n\n  let neighbors: [number, number][] = [];\n  let neighborX: number = -1;\n  let neighborY: number = -1;\n\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n    if (\n      neighborX >= 0 &&\n      neighborX < columnLength &&\n      neighborY >= 0 &&\n      neighborY < rowLength &&\n      !visited.includes(pairGrid[neighborX][neighborY])\n    ) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n  return neighbors;\n};\n\nexport const getNeighborsEmpty: (\n  pairGrid: [number, number][][],\n  currentNode: [number, number],\n  columnLength: number,\n  rowLength: number\n) => [number, number][] = (pairGrid, currentNode, columnLength, rowLength) => {\n  const directions = [\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n    [0, 1],\n  ];\n\n  let neighbors: [number, number][] = [];\n  let neighborX: number = -1;\n  let neighborY: number = -1;\n\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n    if (\n      neighborX >= 0 &&\n      neighborX < columnLength &&\n      neighborY >= 0 &&\n      neighborY < rowLength\n    ) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n  return neighbors;\n};\n\n// This function returns the neighbors which have a wall with the current node\nconst getWalledOffNeighbors: (\n  pairGrid: [number, number][][],\n  currentNode: [number, number],\n  rowLength: number,\n  columnLength: number,\n  mazeGraph: Map<[number, number], [[number, number], number][]>\n) => [number, number][] = (\n  pairGrid,\n  currentNode,\n  rowLength,\n  columnLength,\n  mazeGraph\n) => {\n  const directions = [\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n    [0, 1],\n  ];\n\n  let neighbors: [number, number][] = [];\n  let neighborX: number = -1;\n  let neighborY: number = -1;\n\n  const findCallback: (neighbor: [[number, number], number]) => boolean = (\n    neighbor\n  ) => {\n    return neighbor[0] === pairGrid[neighborX][neighborY];\n  };\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n\n    if (\n      neighborX >= 0 &&\n      neighborX < columnLength &&\n      neighborY >= 0 &&\n      neighborY < rowLength &&\n      // !mazeGraph.get(currentNode)?.includes(pairGrid[neighborX][neighborY])\n      !mazeGraph.get(currentNode)?.find(findCallback)\n    ) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n  return neighbors;\n};\n","import { node } from \"./usefulInterfaces\";\n\n// This function (Not a React Component!) is made to initialize the grid rendered in the App component.\nexport const constructGrid: (\n  numberOfRows: number,\n  numberOfColumn: number,\n  startNode: [number, number],\n  endNode: [number, number],\n  numberOfTargets: number\n) => [node[][], node, node[]] = (\n  numberOfRow,\n  numberOfColumn,\n  startNode,\n  endNode,\n  numberOfTargets\n) => {\n  let result: node[][] = [];\n  for (let i: number = 0; i < numberOfColumn; i++) {\n    let currentRow: node[] = [];\n    for (let j: number = 0; j < numberOfRow; j++) {\n      let currentNode: node = {\n        id: i + j * numberOfColumn,\n        x: i,\n        y: j,\n        isStart: false,\n        hasCheese: false,\n        hasRat: false,\n        isVisited: false,\n        isShortestPath: false,\n        successorPosition: \"\",\n      };\n      currentRow.push(currentNode);\n    }\n    result.push(currentRow);\n  }\n  result[startNode[0]][startNode[1]].isStart = true;\n  result[startNode[0]][startNode[1]].hasRat = true;\n  result[endNode[0]][endNode[1]].hasCheese = true;\n  let targetList: node[] = [result[endNode[0]][endNode[1]]];\n  if (numberOfTargets >= 1)\n    [result, targetList] = piecesOfCheese(\n      result,\n      startNode,\n      endNode,\n      numberOfTargets\n    );\n  return [result, result[startNode[0]][startNode[1]], targetList];\n};\n\nexport const reconstructGrid: (\n  numberOfRows: number,\n  numberOfColumn: number,\n  startNode: [number, number],\n  targetList: node[]\n) => [node[][], node, node[]] = (\n  numberOfRow,\n  numberOfColumn,\n  startNode,\n  targetList\n) => {\n  let result: node[][] = [];\n  for (let i: number = 0; i < numberOfColumn; i++) {\n    let currentRow: node[] = [];\n    for (let j: number = 0; j < numberOfRow; j++) {\n      let currentNode: node = {\n        id: i + j * numberOfColumn,\n        x: i,\n        y: j,\n        isStart: false,\n        hasCheese: targetList.find(\n          (targetNode) => targetNode.x === i && targetNode.y === j\n        )\n          ? true\n          : false,\n        hasRat: false,\n        isVisited: false,\n        isShortestPath: false,\n        successorPosition: \"\",\n      };\n      currentRow.push(currentNode);\n    }\n    result.push(currentRow);\n  }\n  result[startNode[0]][startNode[1]].isStart = true;\n  result[startNode[0]][startNode[1]].hasRat = true;\n  let newTargetList: node[] = targetList.map(\n    (targetNode) => result[targetNode.x][targetNode.y]\n  );\n  return [result, result[startNode[0]][startNode[1]], newTargetList];\n};\n\nconst piecesOfCheese: (\n  grid: node[][],\n  startNode: [number, number],\n  endNode: [number, number],\n  cheeseNum: number\n) => [node[][], node[]] = (grid, startNode, endNode, cheeseNum) => {\n  const n: number = grid.length,\n    m: number = grid[0].length;\n  const targetList: node[] = [grid[endNode[0]][endNode[1]]];\n  let visited: boolean[][] = new Array(n);\n  for (let i: number = 0; i < n; ++i) {\n    visited[i] = new Array(m);\n  }\n  for (let i: number = 0; i < n; ++i) {\n    for (let j: number = 0; j < m; ++j) {\n      visited[i][j] = false;\n    }\n  }\n\n  visited[startNode[0]][startNode[1]] = true;\n  visited[endNode[0]][endNode[1]] = true;\n  for (let k: number = 0; k < cheeseNum; k++) {\n    let i = -1,\n      j = -1;\n    do {\n      i = Math.floor(Math.random() * n);\n      j = Math.floor(Math.random() * m);\n    } while (visited[i][j]);\n    visited[i][j] = true;\n    grid[i][j].hasCheese = true;\n    targetList.push(grid[i][j]);\n  }\n  return [grid, targetList];\n};\n\nexport const addPiecesOfCheese: (\n  numberOfRows: number,\n  numberOfColumn: number,\n  startNode: node,\n  oldTargetList: node[],\n  cheeseToAdd: number\n) => [node[][], node, node[]] = (\n  numberOfRows,\n  numberOfColumn,\n  startNode,\n  oldTargetList,\n  cheeseToAdd\n) => {\n  // let targetList: node[] = [];\n  while (cheeseToAdd < 0) {\n    let randIndex: number = Math.floor(Math.random() * oldTargetList.length);\n    oldTargetList = oldTargetList.filter(\n      (targetNode, index) => index !== randIndex\n    );\n    cheeseToAdd++;\n  }\n\n  const [newGrid, newStartNode, targetList] = reconstructGrid(\n    numberOfRows,\n    numberOfColumn,\n    [startNode.x, startNode.y],\n    oldTargetList\n  );\n\n  let visited: boolean[][] = new Array(numberOfColumn);\n  for (let i: number = 0; i < numberOfColumn; ++i) {\n    visited[i] = new Array(numberOfRows);\n  }\n  for (let i: number = 0; i < numberOfColumn; ++i) {\n    for (let j: number = 0; j < numberOfRows; ++j) {\n      visited[i][j] = false;\n    }\n  }\n\n  visited[startNode.x][startNode.y] = true;\n  targetList.forEach((targetNode) => {\n    visited[targetNode.x][targetNode.y] = true;\n  });\n  for (let k: number = 0; k < cheeseToAdd; k++) {\n    let i = -1,\n      j = -1;\n    do {\n      i = Math.floor(Math.random() * numberOfColumn);\n      j = Math.floor(Math.random() * numberOfRows);\n    } while (visited[i][j]);\n    visited[i][j] = true;\n    newGrid[i][j].hasCheese = true;\n    targetList.push(newGrid[i][j]);\n  }\n  return [newGrid, newStartNode, targetList];\n};\n","import React, { useRef } from \"react\";\nimport { CSSTransition } from \"react-transition-group\";\n\ninterface WrapperProps {\n  handleEnter: any;\n  timeout: number;\n  classNames: string;\n  in: boolean;\n  unmountOnExit: boolean;\n  appear?: boolean;\n}\n\nexport const WrapperCSSTransition: React.FC<WrapperProps> = ({\n  handleEnter,\n  ...props\n}) => {\n  const nodeRef = useRef<HTMLDivElement>(null);\n\n  // This function calculates the height of a DOM element\n  const calcHeight: (isAppearing: boolean) => void = (isAppearing) => {\n    const el = nodeRef.current;\n    const height: number = el !== null ? el.offsetHeight : 0;\n    handleEnter(height);\n  };\n\n  return (\n    <CSSTransition nodeRef={nodeRef} {...props} onEnter={calcHeight}>\n      <div className=\"menu\" ref={nodeRef}>\n        {props.children}\n      </div>\n    </CSSTransition>\n  );\n};\n","import React, { useEffect, useRef, useState } from \"react\";\nimport \"./Visualizer.css\";\nimport { Grid } from \"../Grid/Grid\";\nimport {\n  NavBar,\n  NavItem,\n  DropDownMenu,\n  DropDownItem,\n  DropDownSlider,\n  NavButton,\n  DropDownToggleSwich,\n  NavSlider,\n} from \"../NavBar/NavBar\";\nimport { node } from \"../helperFunctions/usefulInterfaces\";\nimport {\n  singleTargetAlgorithms,\n  multipleTargetsAlgorithms,\n} from \"../helperFunctions/shortestPathAlgorithms/allAlgorithms\";\nimport { generateMazeGraph } from \"../helperFunctions/mazeGenerators/mazeGraph\";\nimport {\n  addPiecesOfCheese,\n  constructGrid,\n  reconstructGrid,\n} from \"../helperFunctions/constructGrid\";\nimport { WrapperCSSTransition } from \"../Wrapper/Wrapper\";\n\nconst NUMBER_OF_COLUMNS: number = 28;\nconst NUMBER_OF_ROWS: number = 13;\nconst VISITED_ANIMATION_TIMEOUT: number = 35;\nconst PATH_ANIMATION_TIMEOUT: number = 125;\nconst FIRST_START_NODE: [number, number] = [6, 3];\nconst FIRST_END_NODE: [number, number] = [6, 24];\nconst FIRST_WALLS_DENSITY: number = 0.4;\nconst FIRST_MUD_DENSITY: number = 0.4;\nconst FIRST_MUD_WEIGHT: number = 4;\n// We define these constants out of the functional component\n// that the App uses to avoid re-running the functions to create\n// these each time there is a re-render\n\nconst [firstGrid, firstStartNode, firstTargetList] = constructGrid(\n  NUMBER_OF_COLUMNS,\n  NUMBER_OF_ROWS,\n  FIRST_START_NODE,\n  FIRST_END_NODE,\n  0\n);\n\nconst [firstpairGrid, mazeGraph] = generateMazeGraph(\n  NUMBER_OF_COLUMNS,\n  NUMBER_OF_ROWS,\n  firstGrid,\n  FIRST_WALLS_DENSITY,\n  FIRST_MUD_DENSITY,\n  FIRST_MUD_WEIGHT\n);\n\n// Component rendering everything in the webpage.\nconst Visualizer: React.FC = () => {\n  const gridRef = useRef(firstGrid);\n  // States managing the grid\n  const [grid, setGrid] = useState(firstGrid);\n  const [pairGrid, setPairGrid] = useState(firstpairGrid);\n  const [isVisualized, setIsVisualized] = useState(0);\n\n  // States managing the maze\n  const [maze, setMaze] = useState(mazeGraph);\n  const [wallsDensity, setWallsDensity] = useState(FIRST_WALLS_DENSITY);\n  const [mudDensity, setMudDensity] = useState(FIRST_MUD_DENSITY);\n  const [mudWeight, setMudWeight] = useState(FIRST_MUD_WEIGHT);\n  const [numberOfTargets, setNumberOfTargets] = useState(1);\n  const [shouldGenerateMaze, setShouldGenerateMaze] = useState(false);\n  const didMount = useRef(false);\n  const [showNumbers, setShowNumbers] = useState(false);\n\n  // States of the start and end nodes\n  const [startNode, setStartNode] = useState(firstStartNode);\n  const [targetList, setTargetList] = useState(firstTargetList);\n\n  // States managing the dropdown menu\n  const [algoActiveMenu, setAlgoActiveMenu] = useState(\"main-single-target\");\n  const [singleTargetAlgorithm, setSingleTargetAlgorithm] = useState(\n    \"Dijkstra's algorithm\"\n  );\n  const [multipleTargetsAlgorithm, setMultipleTargetsAlgorithm] = useState(\n    \"Nearest Neighbors Heuristic\"\n  );\n  const [height, setHeight] = useState(undefined);\n\n  // State of the mouse\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\n  const draggedNode = useRef(startNode);\n\n  // This function is there to visualize the algorithm chosen in the drop down menu\n  const visualizeSingleTargetAlgorithm: (\n    visited: node[],\n    path: node[],\n    timeout: number\n  ) => number = (visited, path, timeout) => {\n    const n = visited.length;\n    for (let i: number = 0; i < n; i++) {\n      setTimeout(() => {\n        const newGrid: node[][] = gridRef.current.slice();\n        const node: node = visited[i];\n        // define the x and y of the current node\n        const x: number = node.x;\n        const y: number = node.y;\n        newGrid[x][y] = {\n          ...gridRef.current[x][y],\n          isVisited: true,\n        };\n        gridRef.current = newGrid;\n        setGrid(newGrid);\n      }, timeout + VISITED_ANIMATION_TIMEOUT * i);\n    }\n\n    const m = path.length;\n    for (let i: number = 0; i < m; i++) {\n      setTimeout(() => {\n        const newGrid: node[][] = gridRef.current.slice();\n        const successor: node = i < m - 1 ? path[i + 1] : path[i];\n        const node: node = path[i];\n        // define the x and y of the current node\n        const x: number = node.x;\n        const y: number = node.y;\n\n        newGrid[x][y] = {\n          ...gridRef.current[x][y],\n          isShortestPath: true,\n          isVisited: false,\n          successorPosition: getSuccessorPosition(node, successor),\n        };\n        gridRef.current = newGrid;\n        setGrid(newGrid);\n      }, timeout + VISITED_ANIMATION_TIMEOUT * n + PATH_ANIMATION_TIMEOUT * i + 500);\n    }\n    return timeout + VISITED_ANIMATION_TIMEOUT * n + PATH_ANIMATION_TIMEOUT * m;\n  };\n\n  // This function returns the position of the successor of a node in the shortest path\n  const getSuccessorPosition: (node: node, successor: node) => string = (\n    node,\n    successor\n  ) => {\n    if (node.x + 1 === successor.x) return \"D\";\n    if (node.y + 1 === successor.y) return \"R\";\n    if (node.x - 1 === successor.x) return \"U\";\n    if (node.y - 1 === successor.y) return \"L\";\n    return \"\";\n  };\n\n  // This function is there to visualize multipleTargetsAlgorithms\n  const visualizeMultipleTargetsAlgorithm: (\n    allVisitedAndPathsArray: [node[], node[]][]\n  ) => number = (allVisitedAndPathsArray) => {\n    let n: number = allVisitedAndPathsArray.length;\n    let currentTimeout: number = 0;\n    for (let i: number = 0; i < n; i++) {\n      const [visited, path] = allVisitedAndPathsArray[i];\n      currentTimeout = visualizeSingleTargetAlgorithm(\n        visited,\n        path,\n        currentTimeout\n      );\n\n      currentTimeout += visited.length > 0 ? 1250 : 0;\n      setTimeout(() => {\n        const newGrid: node[][] = gridRef.current.slice();\n        for (let x: number = 0; x < newGrid.length; x++) {\n          for (let y: number = 0; y < newGrid[0].length; y++) {\n            newGrid[x][y] = {\n              ...gridRef.current[x][y],\n              isVisited: false,\n            };\n          }\n        }\n        gridRef.current = newGrid;\n        setGrid(newGrid);\n      }, currentTimeout);\n      currentTimeout += 1000;\n    }\n    return currentTimeout;\n  };\n\n  // This function is passed to the drop down menu to handle the change of algorithm\n  const handleAlgorithmChange: (algorithmName: string) => () => void = (\n    algorithmName\n  ) => {\n    return () => {\n      numberOfTargets > 1\n        ? setMultipleTargetsAlgorithm(algorithmName)\n        : setSingleTargetAlgorithm(algorithmName);\n    };\n  };\n\n  // This function handles the click on the menu buttons\n  const handleMenuChange: (menuName: string) => () => void = (menuName) => {\n    return () => setAlgoActiveMenu(menuName);\n  };\n\n  // This function handles the logic of the visualization of the algorithms\n  const handleVisualization: () => void = () => {\n    if (isVisualized === 0) {\n      setIsVisualized(1);\n      if (numberOfTargets === 1) {\n        const [visited, path]: [node[], node[]] = singleTargetAlgorithms[\n          singleTargetAlgorithm\n        ](\n          grid,\n          pairGrid,\n          maze,\n          startNode,\n          targetList.map((targetNode) => grid[targetNode.x][targetNode.y])\n        );\n        const n: number = visited.length,\n          m: number = path.length;\n        visualizeSingleTargetAlgorithm(visited, path, 0);\n        setTimeout(() => {\n          setIsVisualized(2);\n        }, VISITED_ANIMATION_TIMEOUT * n + PATH_ANIMATION_TIMEOUT * m + 1250);\n        return;\n      }\n      const allVisitedAndPaths: [node[], node[]][] = multipleTargetsAlgorithms[\n        multipleTargetsAlgorithm\n      ](grid, pairGrid, maze, startNode, targetList.slice())[0];\n      const timeout: number = visualizeMultipleTargetsAlgorithm(\n        allVisitedAndPaths\n      );\n      setTimeout(() => {\n        setIsVisualized(2);\n      }, timeout);\n    }\n    if (isVisualized === 2) {\n      reinitializeGrid();\n    }\n  };\n\n  // This function calls the generate maze function\n  const generateMaze: () => void = () => {\n    if (isVisualized === 0) {\n      const [newPairGrid, newMaze] = generateMazeGraph(\n        NUMBER_OF_COLUMNS,\n        NUMBER_OF_ROWS,\n        grid,\n        wallsDensity,\n        mudDensity,\n        mudWeight\n      );\n      setPairGrid(newPairGrid);\n      setMaze(newMaze);\n      setShouldGenerateMaze(false);\n    }\n  };\n\n  // Reinitialize the the board\n  const reinitializeGrid: () => void = () => {\n    if (isVisualized !== 1) {\n      const [newGrid, newStartNode, newTargetList] = reconstructGrid(\n        NUMBER_OF_COLUMNS,\n        NUMBER_OF_ROWS,\n        [startNode.x, startNode.y],\n        targetList\n      );\n      for (let i: number = 0; i < newGrid.length; i++) {\n        for (let j: number = 0; j < newGrid[0].length; j++) {\n          gridRef.current[i][j] = newGrid[i][j];\n        }\n      }\n      gridRef.current = newGrid;\n      setGrid(newGrid);\n      setStartNode(newStartNode);\n      setTargetList(newTargetList);\n      setIsVisualized(0);\n    }\n  };\n\n  // toggles on and off the multiple targets\n  const toggleMultipleTargetGrid: () => void = () => {\n    if (isVisualized !== 1) {\n      let newGrid, newStartNode, newTargetList;\n      if (numberOfTargets > 1) {\n        [newGrid, newStartNode, newTargetList] = addPiecesOfCheese(\n          NUMBER_OF_COLUMNS,\n          NUMBER_OF_ROWS,\n          startNode,\n          targetList,\n          numberOfTargets - targetList.length\n        );\n        for (let i: number = 0; i < newGrid.length; i++) {\n          for (let j: number = 0; j < newGrid[0].length; j++) {\n            gridRef.current[i][j] = newGrid[i][j];\n          }\n        }\n      } else {\n        [newGrid, newStartNode, newTargetList] = constructGrid(\n          NUMBER_OF_COLUMNS,\n          NUMBER_OF_ROWS,\n          [startNode.x, startNode.y],\n          FIRST_END_NODE,\n          0\n        );\n      }\n      gridRef.current = newGrid;\n      setGrid(newGrid);\n      setStartNode(newStartNode);\n      setTargetList(newTargetList);\n      setIsVisualized(0);\n    }\n  };\n\n  // If the value of multipleTargets change, call the reinitialize function\n  useEffect(toggleMultipleTargetGrid, [numberOfTargets]);\n\n  // handle the change of the number of targets\n  const handleChangeNumberOfTargets: (val: number) => void = (val) => {\n    setNumberOfTargets(Math.floor(val));\n  };\n\n  // handle the click on the multiple targets button\n  const handleMultipleTargets: () => void = () => {\n    if (isVisualized === 0) {\n      setAlgoActiveMenu(\n        numberOfTargets > 1 ? \"main-single-target\" : \"main-multiple-target\"\n      );\n      setNumberOfTargets(numberOfTargets > 1 ? 1 : 5);\n    }\n  };\n\n  const toggleNode: (currentNode: node) => void = (currentNode) => {\n    let oldStartNode: node = startNode,\n      oldTargetList: node[] = targetList.slice();\n    if (draggedNode.current === startNode) {\n      oldStartNode = currentNode;\n    } else {\n      const isTargetNode: boolean = targetList.find(\n        (targetNode) => targetNode === currentNode\n      )\n        ? true\n        : false;\n      if (!isTargetNode) {\n        oldTargetList = oldTargetList.filter(\n          (targetNode) => targetNode !== draggedNode.current\n        );\n        oldTargetList.push(currentNode);\n      }\n    }\n    const [newGrid, newStartNode, newTargetList] = reconstructGrid(\n      NUMBER_OF_COLUMNS,\n      NUMBER_OF_ROWS,\n      [oldStartNode.x, oldStartNode.y],\n      oldTargetList\n    );\n    for (let x: number = 0; x < newGrid.length; x++) {\n      for (let y: number = 0; y < newGrid[0].length; y++) {\n        gridRef.current[x][y] = newGrid[x][y];\n      }\n    }\n    draggedNode.current = newGrid[currentNode.x][currentNode.y];\n    setStartNode(newStartNode);\n    setTargetList(newTargetList);\n    gridRef.current = newGrid;\n    setGrid(newGrid);\n  };\n\n  // handles the case when the mouse button is down\n  const handleMouseDown: (currentNode: node) => void = (currentNode) => {\n    const isTargetNode: boolean = targetList.find(\n      (targetNode) => targetNode === currentNode\n    )\n      ? true\n      : false;\n    if (isVisualized === 0 && (currentNode === startNode || isTargetNode)) {\n      setMouseIsPressed(true);\n      draggedNode.current = currentNode;\n    }\n  };\n\n  // handles the case whan the mouse button is down and you enter a node\n  const handleMouseEnter: (currentNode: node) => void = (currentNode) => {\n    if (mouseIsPressed) {\n      toggleNode(currentNode);\n    }\n  };\n\n  // handles the case when you mouse up\n  const handleMouseUp: () => void = () => {\n    setMouseIsPressed(false);\n  };\n\n  // function that returns the text in the visualization button\n  const getVisualizeText: () => string = () => {\n    if (isVisualized <= 0)\n      return (\n        \"Visualize \" +\n        (numberOfTargets > 1\n          ? multipleTargetsAlgorithm\n          : singleTargetAlgorithm) +\n        \"!\"\n      );\n    return \"Reinitialize Visualization\";\n  };\n\n  // updates the maze in real time\n  useEffect(() => {\n    if (didMount.current) setShouldGenerateMaze(true);\n    else didMount.current = true;\n  }, [wallsDensity, mudDensity, mudWeight]);\n\n  // Render the app\n  return (\n    <div className=\"App\" onMouseUp={() => handleMouseUp()}>\n      <NavBar>\n        <NavButton\n          text=\"Generate New Maze\"\n          isVisualized={isVisualized}\n          className={\n            \"generate-maze \" + (shouldGenerateMaze ? \"should-generate\" : \"\")\n          }\n          visualizingClassName=\"greyed-out\"\n          visualizedClassName=\"greyed-out\"\n          handleClick={generateMaze}\n        />\n        <NavItem\n          text=\"Maze options\"\n          id=\"maze-options\"\n          isVisualized={isVisualized}\n          shouldGreyOut={true}\n        >\n          <DropDownMenu left={true}>\n            <DropDownSlider\n              text=\"Density of walls:\"\n              minValue={0}\n              maxValue={1}\n              step={0.01}\n              defaultValue={wallsDensity}\n              handleChange={setWallsDensity}\n            ></DropDownSlider>\n            <DropDownSlider\n              text=\"Density of mud:\"\n              minValue={0}\n              maxValue={1}\n              step={0.01}\n              defaultValue={mudDensity}\n              handleChange={setMudDensity}\n            ></DropDownSlider>\n            <DropDownSlider\n              text=\"Mud Weight:\"\n              minValue={1.1}\n              maxValue={10}\n              step={0.1}\n              defaultValue={mudWeight}\n              handleChange={setMudWeight}\n            ></DropDownSlider>\n            <DropDownToggleSwich\n              text=\"Show Mud Weights ?\"\n              shouldShowWeights={showNumbers}\n              handleChange={() => setShowNumbers(!showNumbers)}\n            />\n          </DropDownMenu>\n        </NavItem>\n        <NavSlider\n          className={\n            numberOfTargets > 1 ? \"show-nav-slider\" : \"hide-nav-slider\"\n          }\n          text=\"Number of Targets:\"\n          minValue={2}\n          maxValue={10}\n          step={1}\n          defaultValue={numberOfTargets}\n          handleChange={handleChangeNumberOfTargets}\n          isVisualized={isVisualized}\n          visualizingClassName=\"greyed-out\"\n          visualizedClassName=\"greyed-out\"\n        />\n\n        <NavButton\n          text={\n            (numberOfTargets > 1 ? \"Disable\" : \"Enable\") + \" Multiple Targets\"\n          }\n          isVisualized={isVisualized}\n          className={\n            numberOfTargets > 1\n              ? \"disable-multiple-targets\"\n              : \"enable-multiple-targets\"\n          }\n          visualizingClassName=\"greyed-out\"\n          visualizedClassName=\"greyed-out\"\n          handleClick={handleMultipleTargets}\n        />\n        <NavButton\n          text={getVisualizeText()}\n          isVisualized={isVisualized}\n          className=\"visualize-button\"\n          visualizingClassName=\"greyed-out highlight\"\n          visualizedClassName=\"highlight\"\n          handleClick={handleVisualization}\n        />\n        <NavItem\n          text=\"Algorithms\"\n          id=\"algorithms\"\n          isVisualized={isVisualized}\n          shouldGreyOut={false}\n        >\n          <DropDownMenu height={height}>\n            <WrapperCSSTransition\n              in={algoActiveMenu === \"main-single-target\"}\n              unmountOnExit\n              timeout={500}\n              classNames=\"menu-primary\"\n              handleEnter={setHeight}\n              appear\n            >\n              <DropDownItem handleClick={handleMenuChange(\"unweighted\")}>\n                <p>Algorithms for unweighted graphs</p>\n                <p className=\"arrow-right\">{\">\"}</p>\n              </DropDownItem>\n              <DropDownItem handleClick={handleMenuChange(\"weighted\")}>\n                <p>Algorithms for weighted graphs</p>\n                <p className=\"arrow-right\">{\">\"}</p>\n              </DropDownItem>\n            </WrapperCSSTransition>\n            <WrapperCSSTransition\n              in={algoActiveMenu === \"unweighted\"}\n              unmountOnExit\n              timeout={500}\n              classNames=\"menu-unweighted\"\n              handleEnter={setHeight}\n            >\n              <DropDownItem\n                handleClick={handleMenuChange(\"main-single-target\")}\n              >\n                <p className=\"arrow-left\">{\"<\"}</p>\n              </DropDownItem>\n              <DropDownItem\n                handleClick={handleAlgorithmChange(\"Depth First Search\")}\n              >\n                <p>Random Depth First Search</p>\n                {singleTargetAlgorithm === \"Depth First Search\" ? (\n                  <p className=\"tickmark\">‚úì</p>\n                ) : (\n                  \"\"\n                )}\n              </DropDownItem>\n              <DropDownItem\n                handleClick={handleAlgorithmChange(\"Breadth First Search\")}\n              >\n                <p>Breadth First Search</p>\n                {singleTargetAlgorithm === \"Breadth First Search\" ? (\n                  <p className=\"tickmark\">‚úì</p>\n                ) : (\n                  \"\"\n                )}\n              </DropDownItem>\n              <DropDownItem\n                handleClick={handleAlgorithmChange(\"Meet in the Middle BFS\")}\n              >\n                <p>Meet in the Middle BFS</p>\n                {singleTargetAlgorithm === \"Meet in the Middle BFS\" ? (\n                  <p className=\"tickmark\">‚úì</p>\n                ) : (\n                  \"\"\n                )}\n              </DropDownItem>\n            </WrapperCSSTransition>\n            <WrapperCSSTransition\n              in={algoActiveMenu === \"weighted\"}\n              unmountOnExit\n              timeout={500}\n              classNames=\"menu-weighted\"\n              handleEnter={setHeight}\n            >\n              <DropDownItem\n                handleClick={handleMenuChange(\"main-single-target\")}\n              >\n                <p className=\"arrow-left\">{\"<\"}</p>\n              </DropDownItem>\n              <DropDownItem\n                handleClick={handleAlgorithmChange(\"Dijkstra's algorithm\")}\n              >\n                <p>Dijkstra's Algorithm</p>\n                {singleTargetAlgorithm === \"Dijkstra's algorithm\" ? (\n                  <p className=\"tickmark\">‚úì</p>\n                ) : (\n                  \"\"\n                )}\n              </DropDownItem>\n              <DropDownItem handleClick={handleAlgorithmChange(\"A* algorithm\")}>\n                <p>A* Algorithm</p>\n                {singleTargetAlgorithm === \"A* algorithm\" ? (\n                  <p className=\"tickmark\">‚úì</p>\n                ) : (\n                  \"\"\n                )}\n              </DropDownItem>\n            </WrapperCSSTransition>\n            <WrapperCSSTransition\n              in={algoActiveMenu === \"main-multiple-target\"}\n              unmountOnExit\n              timeout={500}\n              classNames=\"menu-unweighted\"\n              handleEnter={setHeight}\n            >\n              <DropDownItem\n                handleClick={handleAlgorithmChange(\"Brute Force Algorithm\")}\n              >\n                <p>Brute Force Algorithm</p>\n                {multipleTargetsAlgorithm === \"Brute Force Algorithm\" ? (\n                  <p className=\"tickmark\">‚úì</p>\n                ) : (\n                  \"\"\n                )}\n              </DropDownItem>\n              <DropDownItem\n                handleClick={handleAlgorithmChange(\n                  \"Nearest Neighbors Heuristic\"\n                )}\n              >\n                <p>Nearest Neighbors Heuristic</p>\n                {multipleTargetsAlgorithm === \"Nearest Neighbors Heuristic\" ? (\n                  <p className=\"tickmark\">‚úì</p>\n                ) : (\n                  \"\"\n                )}\n              </DropDownItem>\n            </WrapperCSSTransition>\n          </DropDownMenu>\n        </NavItem>\n      </NavBar>\n\n      <Grid\n        grid={grid}\n        pairGrid={pairGrid}\n        maze={maze}\n        mouseState={mouseIsPressed}\n        handleMouseDown={handleMouseDown}\n        handleMouseEnter={handleMouseEnter}\n        showNumbers={showNumbers}\n      />\n    </div>\n  );\n};\n\nexport default Visualizer;\n","import React from \"react\";\n\nimport { BrowserRouter as Router, Switch, Route } from \"react-router-dom\";\nimport Visualizer from \"./Visualizer/Visualizer\";\n\nconst App: React.FC = () => {\n  return (\n    <div>\n      <Router>\n        <Switch>\n          <Route exact path=\"/pathfinding-visualizer\" component={Visualizer} />\n          {/* <Route path=\"/react-rat\" component={ReactRat} /> */}\n        </Switch>\n      </Router>\n    </div>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\n// import PathFindingVisualizer from \"./Visualizer/PathFindingVisualizer\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}