{"version":3,"sources":["Tutorial/imagesAndGifs/infoButton.png","Tutorial/imagesAndGifs/wall.png","Tutorial/imagesAndGifs/mud.png","Tutorial/imagesAndGifs/enableMultipleTargets.gif","Tutorial/imagesAndGifs/chooseAlgorithm.gif","Tutorial/imagesAndGifs/mazeOptions.gif","Tutorial/imagesAndGifs/dragAndDrop.gif","Tutorial/imagesAndGifs/haveFunVisualizing.gif","icon/right-thin-chevron-svgrepo-com.svg","helperFunctions/ensureNotUndefined.ts","GridNode/GridNode.tsx","Grid/Grid.tsx","NavBar/NavBar.tsx","helperFunctions/shortestPathAlgorithms/retrievePath.ts","helperFunctions/dataStructures/binaryHeap.ts","helperFunctions/shortestPathAlgorithms/singleTarget/dijkstra.ts","helperFunctions/shortestPathAlgorithms/singleTarget/aStar.ts","helperFunctions/shortestPathAlgorithms/multipleTarget/greedy.ts","helperFunctions/shortestPathAlgorithms/multipleTarget/bruteForce.ts","helperFunctions/shortestPathAlgorithms/allAlgorithms.ts","helperFunctions/shortestPathAlgorithms/singleTarget/dfs.ts","helperFunctions/shortestPathAlgorithms/singleTarget/bfs.ts","helperFunctions/shortestPathAlgorithms/singleTarget/twoEndedBfs.ts","helperFunctions/mazeGenerators/mazeGraph.ts","helperFunctions/constructGrid.ts","Wrapper/Wrapper.tsx","Tutorial/Tutorial.tsx","NavBar/NavButton.tsx","NavBar/DropDownAlgo.tsx","NavBar/DropDownMenu.tsx","NavBar/DropDownSlider.tsx","NavBar/DropDownToggleSwitch.tsx","NavBar/NavItem.tsx","NavBar/NavSlider.tsx","Tutorial/InfoButton.tsx","NavBar/EnergyCost.tsx","Visualizer/Visualizer.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","_objectWithoutProperties","excluded","sourceKeys","keys","indexOf","_objectWithoutPropertiesLoose","getOwnPropertySymbols","sourceSymbolKeys","propertyIsEnumerable","_ref2","createElement","_ref3","_ref4","_ref5","_ref6","_ref7","_ref8","_ref9","_ref10","_ref11","_ref12","_ref13","_ref14","_ref15","_ref16","_ref","svgRef","title","props","id","x","y","viewBox","style","enableBackground","xmlSpace","ref","fill","d","ForwardRef","forwardRef","ensure","argument","message","undefined","TypeError","getAddedClassName","neighbors","node","addedClassName","neighbor","neighborX","neighborY","distance","hasCheese","isShortestPath","isVisited","GridNode","React","memo","numberOfElementsPerRow","handleMouseDown","mouseState","handleMouseEnter","showNumbers","className","onMouseDown","e","onMouseEnter","role","aria-label","hasRat","successorPosition","isStart","find","prevProps","nextProps","Grid","grid","maze","pairGrid","children","map","row","rowLength","index","get","NavBar","retrievePath","predecessor","startNode","endNode","shortestPath","current","unshift","retrieveDistance","path","mazeGraph","predNode","currNode","pred","curr","neighborEdge","BinaryHeap","compare","content","element","push","bubbleUp","result","end","pop","sinkDown","n","parentN","Math","floor","parent","child2N","child1N","swap","dijkstraHelper","oldTargetList","m","targetList","slice","distances","j","Number","MAX_SAFE_INTEGER","visited","pq","a","b","currentNode","targetNode","currentX","currentY","nextNode","currentDistance","visitedNode","remove","size","dijkstra","manhattanDistance","abs","greedy","currentStartNode","totalDistance","allVisitedAndPaths","filter","getTrueOptimalPath","optimalPath","actualPath","singleTargetAlgorithms","discovered","stack","discoveredNode","q","shift","dA","dB","successor","foundNode","middleNode","retrieveTwoEndedPath","multipleTargetsAlgorithms","newTargetList","distancesMatrix","getDistanceMatrix","maxCost","maxLength","branchAndBound","candidatePath","remainingTargets","currentCost","newRemainingTargets","forEach","targetNodeAndIndex","prevId","tgAndId","console","log","valueIndexPair","generateMazeGraph","columnLength","wallsDensity","mudDensity","mudWeight","MUD_WEIGHT","pairRow","Map","set","createMazeGraph","currentWallsCount","maxWallsOrMud","currentNonVisitedNeighbors","getNeighbors","neighborNode","random","maxWallsCount","randRow","randCol","getWalledOffNeighbors","randIndex","currentMud","maxMud","item","neighborNodeNeighbors","dir","includes","findCallback","constructGrid","numberOfRow","numberOfColumn","numberOfTargets","currentRow","piecesOfCheese","reconstructGrid","cheeseNum","Array","k","WrapperCSSTransition","handleEnter","divClassName","nodeRef","useRef","CSSTransition","onEnter","isAppearing","el","height","offsetHeight","Tutorial","useState","activePage","setActivePage","showTutorial","in","unmountOnExit","timeout","classNames","leftButton","rightButton","rightOnClick","handleDismiss","alt","src","require","leftOnClick","Page","onClick","NavButton","addedClassNames","startClassName","visualizingClassName","visualizedClassName","isVisualized","handleClick","text","DropDownItem","DropDownMenu","left","DropDownSlider","defaultValue","type","value","min","minValue","toString","max","maxValue","step","onChange","handleChange","DropDownToggleSwich","checked","shouldShowWeights","NavItem","open","setOpen","shouldGreyOut","event","document","addEventListener","dropDownMenu","getElementById","targetElement","parentNode","NavSlider","InfoButton","EnergyCost","showDistance","FIRST_END_NODE","firstGrid","firstStartNode","firstTargetList","firstpairGrid","Visualizer","setShowTutorial","gridRef","setGrid","setPairGrid","setIsVisualized","setMaze","setWallsDensity","setMudDensity","setMudWeight","setNumberOfTargets","shouldGenerateMaze","setShouldGenerateMaze","didMount","setShowNumbers","setStartNode","setTargetList","algoActiveMenu","setAlgoActiveMenu","singleTargetAlgorithm","setSingleTargetAlgorithm","multipleTargetsAlgorithm","setMultipleTargetsAlgorithm","setShowDistance","setDistance","setHeight","mouseIsPressed","setMouseIsPressed","draggedNode","visualizeSingleTargetAlgorithm","setTimeout","newGrid","getSuccessorPosition","handleAlgorithmChange","algorithmName","handleMenuChange","menuName","reinitializeGrid","newStartNode","useEffect","numberOfRows","cheeseToAdd","addPiecesOfCheese","onMouseUp","newPairGrid","newMaze","val","newDistance","allVisitedAndPathsArray","currentTimeout","visualizeMultipleTargetsAlgorithm","appear","isTargetNode","oldStartNode","toggleNode","App","exact","component","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error"],"mappings":"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","file":"static/js/main.5f163718.chunk.js","sourcesContent":["module.exports = \"data:image/png;base64,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\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAO4AAACoCAYAAADn79JTAAAABHNCSVQICAgIfAhkiAAAABl0RVh0U29mdHdhcmUAZ25vbWUtc2NyZWVuc2hvdO8Dvz4AAAApdEVYdENyZWF0aW9uIFRpbWUAbHVuLiAxNCBzZXB0LiAyMDIwIDA4OjQ2OjUwmP0ORgAAAuBJREFUeJzt1zFu3FYYRtF/AkHUArJSVdYKpEq7dKfGrkg1k8KwjQRuZEh5uPQ5Faf7SPCC8y4v+36dEziO15mZuc6327nbtpVzltiPY2ZmLnOZmZltu105Z5nv78J3Z3wOf60eALydcCFIuBAkXAgSLgQJF4KEC0HChSDhQpBwIUi4ECRcCBIuBAkXgoQLQcKFIOFCkHAhSLgQJFwIEi4ECReChAtBwoUg4UKQcCFIuBAkXAgSLgQJF4KEC0HChSDhQpBwIUi4ECRcCBIuBAkXgoQLQcKFIOFCkHAhSLgQJFwIEi4ECReChAtBl89fvl5Xj3hP1znV7fyWy1xWT+CD+eJC0M3qAbyv58fHmZm5f3hYvGS9M//zEO6JPD8+zvPT04/f4j2vy8u+n+JQeByvM/PzjHu3bSvnLPH33d2/fr/s+6Ila+3HMTM/v7jbdrtyzodwxoUg4UKQcCFIuBAkXAgSLgQJF4KEC0HChSDhQpBwIUi4ECRcCBIuBAkXgoQLQcKFIOFCkHAhSLgQJFwIEi4ECReChAtBwoUg4UKQcCFIuBAkXAgSLgQJF4KEC0HChSDhQpBwIUi4ECRcCBIuBAkXgoQLQcKFIOFCkHAhSLgQJFwIEi4ECReChAtBwoUg4UKQcCFIuBAkXAgSLgQJF4KEC0HChSDhQpBwIUi4EHRzHK+rN3yI/ThWT/jf3X/6NM9PTz+u/8Rn8CtnfMdvVg/g/dw/PPzymvO5fP7y9bp6BPA2zrgQdLNtt6s3vIv/nmPOcl9v4Rl88yc8B19cCBIuBAkXgoQLQcKFIOFCkHAhSLgQJFwIEi4ECReChAtBwoUg4UKQcCFIuBAkXAgSLgQJF4KEC0HChSDhQpBwIUi4ECRcCBIuBAkXgoQLQcKFIOFCkHAhSLgQJFwIEi4ECReChAtBwoUg4UKQcCFIuBAkXAgSLgQJF4KEC0HChSDhQpBwIUi4ECRcCBIuBP0D2W9MJbYYohQAAAAASUVORK5CYII=\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANEAAACPCAYAAABkvj5oAAAABHNCSVQICAgIfAhkiAAAABl0RVh0U29mdHdhcmUAZ25vbWUtc2NyZWVuc2hvdO8Dvz4AAAApdEVYdENyZWF0aW9uIFRpbWUAbHVuLiAxNCBzZXB0LiAyMDIwIDA4OjQ5OjE2TZF+IQAAA5xJREFUeJzt3VFrW3UYx/Ena7q4tayztWzr7OYQvBD11kth997orS/NN7O9g6GgA4VZ2UYhLVZimyYt9cIS7Ryu8gP/J+bzucrJRXk4yZectOU8veF4fFaNHR9PLhwPBlcbTdKOczC/5+BK6wFg3okIQiKCkIggJCIIiQhCIoKQiCAkIgiJCEIigpCIICQiCIkIQiKCkIggJCIIiQhCIoKQiCAkIgiJCEIigpCIICQiCIkIQiKCkIggJCIIiQhCIoKQiCAkIgj1nh/82nxTHswzn0QQ6rce4IJer/UETU33XlRV1fLGVuNJGjubr4ujbkW0wKZ7L2q6vzs7XviQ5ki/Cxua/7Y1+upyo0naOfxLQNP93Vq9c7/hNG0cT6YXjrvw3rwM34kgJCIIiQhCIoKQiCAkIgiJCEIigpCIICQiCIkIQiKCkIggJCIIiQhCIoKQiCAkIgiJCEIigpCIICQiCIkIQm7e2EW93+rg8de1P5zU4KOvauuDG60n4h+IqGt64xr/8KTGJ/Nx40JcznXMaU12vqnDUb9WH9zz4swJr1OHnB58X6PhuJa2P67Nreutx+GSRNQV05c1ejas3tsf1o31a62n4V8QUSeM6ujZj3WydLtW3tuoxV4wM39E1AGnPz+qo1G/BvfeL79OmD8iaq33svaf7FRdu12Dt07qdDKu08m4JudrRs6Oj2pyOH3DD6Gl3nA8br6WbLaf6HxT3kLtJ9p7XDuPvq3J4ejC00vXV/88ONuuzS8/r9X6f5vtJzrflDcv+4n8nai1tU9q49N3a/TTdxeeXl07qeHT53Vl+7Na39qsQaPxeDMRtda/WSt3b9bkl+GFp1feGdXwadXS2nat3PUfC13mOxGERAQhl3Nddeth3f/iYespuASfRBASEYREBCERQUhEEBIRhEQEIRFBSEQQEhGERAQhEUFIRBASEYREBCERQUhEEBIRhEQEIRFBSEQQEhGERASh/uxm8h0yu7H5Allev1XT/d3Z40U8B6/q4nvzddy8sSOWN7Ze+5ju61ZEZ823vDS1vH7njwcLfh7mje9EEOp3YZHSq9e+XZjpv+YczO858EkEIRFBSEQQEhGERAQhEUFIRBASEYREBCERQUhEEBIRhEQEIRFBSEQQEhGERAQhEUFIRBASEYREBCERQUhEEBIRhEQEIRFBSEQQEhGERAQhEUFIRBASEYREBCERQUhEEBIRhEQEIRFBSEQQ+h1AQaP1o4u4ggAAAABJRU5ErkJggg==\"","module.exports = __webpack_public_path__ + \"static/media/enableMultipleTargets.df35fb6a.gif\";","module.exports = __webpack_public_path__ + \"static/media/chooseAlgorithm.4a57bca2.gif\";","module.exports = __webpack_public_path__ + \"static/media/mazeOptions.eec2db15.gif\";","module.exports = __webpack_public_path__ + \"static/media/dragAndDrop.edd15b62.gif\";","module.exports = __webpack_public_path__ + \"static/media/haveFunVisualizing.8adb7198.gif\";","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React from \"react\";\n\nvar _ref2 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar _ref3 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar _ref4 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar _ref5 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar _ref6 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar _ref7 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar _ref8 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar _ref9 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar _ref10 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar _ref11 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar _ref12 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar _ref13 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar _ref14 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar _ref15 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar _ref16 = /*#__PURE__*/React.createElement(\"g\", null);\n\nvar SvgRightThinChevronSvgrepoCom = function SvgRightThinChevronSvgrepoCom(_ref) {\n  var svgRef = _ref.svgRef,\n      title = _ref.title,\n      props = _objectWithoutProperties(_ref, [\"svgRef\", \"title\"]);\n\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    id: \"Capa_1\",\n    x: \"0px\",\n    y: \"0px\",\n    viewBox: \"0 0 185.343 185.343\",\n    style: {\n      enableBackground: \"new 0 0 185.343 185.343\"\n    },\n    xmlSpace: \"preserve\",\n    ref: svgRef\n  }, props), title ? /*#__PURE__*/React.createElement(\"title\", null, title) : null, /*#__PURE__*/React.createElement(\"g\", null, /*#__PURE__*/React.createElement(\"g\", null, /*#__PURE__*/React.createElement(\"path\", {\n    style: {\n      fill: \"#010002\"\n    },\n    d: \"M51.707,185.343c-2.741,0-5.493-1.044-7.593-3.149c-4.194-4.194-4.194-10.981,0-15.175 l74.352-74.347L44.114,18.32c-4.194-4.194-4.194-10.987,0-15.175c4.194-4.194,10.987-4.194,15.18,0l81.934,81.934 c4.194,4.194,4.194,10.987,0,15.175l-81.934,81.939C57.201,184.293,54.454,185.343,51.707,185.343z\"\n  }))), _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16);\n};\n\nvar ForwardRef = /*#__PURE__*/React.forwardRef(function (props, ref) {\n  return /*#__PURE__*/React.createElement(SvgRightThinChevronSvgrepoCom, _extends({\n    svgRef: ref\n  }, props));\n});\nexport default __webpack_public_path__ + \"static/media/right-thin-chevron-svgrepo-com.e4144d1e.svg\";\nexport { ForwardRef as ReactComponent };","// This function is here to ensure that a value is not undefined (especially when using arrays).\nexport function ensure<T>(\n  argument: T | undefined | null,\n  message: string = \"This value was promised to be there.\"\n): T {\n  if (argument === undefined || argument === null) {\n    throw new TypeError(message);\n  }\n  return argument;\n}\n","import React from \"react\";\nimport \"./GridNode.css\";\nimport { node } from \"../helperFunctions/usefulInterfaces\";\nimport { ReactComponent as ChevronRightIcon } from \"../icon/right-thin-chevron-svgrepo-com.svg\";\nimport { ensure } from \"../helperFunctions/ensureNotUndefined\";\n\ninterface Props {\n  numberOfElementsPerRow: number;\n  node: node;\n  neighbors: [[number, number], number][];\n  mouseState: boolean;\n  handleMouseDown: (currentNode: node) => void;\n  handleMouseEnter: (currentNode: node) => void;\n  showNumbers: boolean;\n}\n\nconst getAddedClassName: (\n  neighbors: [[number, number], number][],\n  node: node\n) => string = (neighbors, node) => {\n  let addedClassName: string = \"\";\n  for (let i = 0; i < neighbors.length; i++) {\n    let neighbor: [[number, number], number] = neighbors[i];\n    let neighborX = neighbor[0][0],\n      neighborY = neighbor[0][1],\n      distance: number = neighbor[1];\n    if (neighborX === node.x + 1)\n      addedClassName += distance === 1 ? \" no-wall-bottom\" : \" mud-bottom\";\n    if (neighborX === node.x - 1)\n      addedClassName += distance === 1 ? \" no-wall-top\" : \" mud-top\";\n    if (neighborY === node.y + 1)\n      addedClassName += distance === 1 ? \" no-wall-right\" : \" mud-right\";\n    if (neighborY === node.y - 1)\n      addedClassName += distance === 1 ? \" no-wall-left\" : \" mud-left\";\n  }\n  if (node.hasCheese) addedClassName += \" cheese\";\n  if (node.isShortestPath && node.isVisited)\n    addedClassName += \" shortest-path-node-being-visited\";\n  else {\n    if (node.isShortestPath) addedClassName += \" shortest-path-node\";\n    if (node.isVisited) addedClassName += \" visited-node\";\n  }\n  return addedClassName;\n};\n\n// This component represents a single Node in the grid rendered in the DOM\nexport const _GridNode: React.FC<Props> = ({\n  numberOfElementsPerRow,\n  node,\n  neighbors,\n  mouseState,\n  handleMouseDown,\n  handleMouseEnter,\n  showNumbers,\n}) => {\n  return (\n    <div\n      className={\"grid-node\" + getAddedClassName(neighbors, node)}\n      onMouseDown={(e) => handleMouseDown(node)}\n      onMouseEnter={(e) => handleMouseEnter(node)}\n    >\n      <span\n        role=\"img\"\n        aria-label=\"rat\"\n        className={node.hasRat ? \"content\" : \"no-content\"}\n      >\n        \n      </span>\n      <span\n        role=\"img\"\n        aria-label=\"rat\"\n        className={node.hasCheese ? \"content\" : \"no-content\"}\n      >\n        \n      </span>\n      <div className={\"svg-chevron \" + node.successorPosition}>\n        {node.isShortestPath && !(node.isStart || node.hasCheese) ? (\n          <ChevronRightIcon />\n        ) : (\n          <span></span>\n        )}\n      </div>\n      {showNumbers &&\n        neighbors.find((neighbor) => neighbor[0][0] === node.x + 1) &&\n        ensure(neighbors.find((neighbor) => neighbor[0][0] === node.x + 1))[1] >\n          1 && (\n          <span className=\"number-bottom\">\n            {\n              ensure(\n                neighbors.find((neighbor) => neighbor[0][0] === node.x + 1)\n              )[1]\n            }\n          </span>\n        )}\n      {showNumbers &&\n        neighbors.find((neighbor) => neighbor[0][1] === node.y + 1) &&\n        ensure(neighbors.find((neighbor) => neighbor[0][1] === node.y + 1))[1] >\n          1 && (\n          <span className=\"number-right\">\n            {\n              ensure(\n                neighbors.find((neighbor) => neighbor[0][1] === node.y + 1)\n              )[1]\n            }\n          </span>\n        )}\n    </div>\n  );\n};\n\nconst areEqual: (prevProps: Props, nextProps: Props) => boolean = (\n  prevProps,\n  nextProps\n) => {\n  return (\n    getAddedClassName(prevProps.neighbors, prevProps.node) ===\n      getAddedClassName(nextProps.neighbors, nextProps.node) &&\n    prevProps.node === nextProps.node &&\n    prevProps.mouseState === nextProps.mouseState &&\n    prevProps.showNumbers === nextProps.showNumbers\n  );\n};\n\nexport const GridNode = React.memo(_GridNode, areEqual);\n","import React from \"react\";\nimport { GridNode } from \"../GridNode/GridNode\";\nimport \"./Grid.css\";\nimport { node } from \"../helperFunctions/usefulInterfaces\";\nimport { ensure } from \"../helperFunctions/ensureNotUndefined\";\n\ninterface Props {\n  grid: node[][];\n  maze: Map<[number, number], [[number, number], number][]>;\n  pairGrid: [number, number][][];\n  mouseState: boolean;\n  handleMouseDown: (currentNode: node) => void;\n  handleMouseEnter: (currentNode: node) => void;\n  showNumbers: boolean;\n}\n\nexport const Grid: React.FC<Props> = ({\n  grid,\n  maze,\n  pairGrid,\n  mouseState,\n  handleMouseDown,\n  handleMouseEnter,\n  showNumbers,\n  children,\n}) => {\n  // Renders the grid in the DOM thanks to the grid state in the App component\n  return (\n    <div className=\"grid\">\n      {grid.map((row, id) => {\n        let rowLength = row.length;\n        return (\n          <div className=\"row\" key={id}>\n            {row.map((node, index) => (\n              <GridNode\n                numberOfElementsPerRow={rowLength}\n                key={id + index * rowLength}\n                node={node}\n                neighbors={ensure(maze.get(pairGrid[node.x][node.y]))}\n                mouseState={mouseState}\n                handleMouseDown={handleMouseDown}\n                handleMouseEnter={handleMouseEnter}\n                showNumbers={showNumbers}\n              ></GridNode>\n            ))}\n          </div>\n        );\n      })}\n      {children}\n    </div>\n  );\n};\n","import React from \"react\";\nimport \"./NavBar.css\";\n\nexport const NavBar: React.FC = (props) => {\n  return (\n    <nav className=\"navbar\">\n      <ul className=\"navbar-nav\">{props.children}</ul>\n    </nav>\n  );\n};\n","import { ensure } from \"../ensureNotUndefined\";\nimport { node } from \"../usefulInterfaces\";\n\nexport const retrievePath: (\n  predecessor: node[],\n  startNode: node,\n  endNode: node\n) => node[] = (predecessor, startNode, endNode) => {\n  let shortestPath = [endNode];\n  let current: node = endNode;\n  while (current.x !== startNode.x || current.y !== startNode.y) {\n    current = predecessor[current.id];\n    shortestPath.unshift(current);\n  }\n\n  return shortestPath;\n};\n\nexport const retrieveTwoEndedPath: (\n  predecessor: node[],\n  successor: node[],\n  middleNode: node,\n  startNode: node,\n  endNode: node\n) => node[] = (predecessor, successor, middleNode, startNode, endNode) => {\n  let shortestPath = [middleNode];\n  let current: node = middleNode;\n  while (current.x !== startNode.x || current.y !== startNode.y) {\n    current = predecessor[current.id];\n    shortestPath.unshift(current);\n  }\n  current = middleNode;\n  while (current.x !== endNode.x || current.y !== endNode.y) {\n    current = successor[current.id];\n    shortestPath.push(current);\n  }\n  return shortestPath;\n};\n\nexport const retrieveDistance: (\n  path: node[],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>\n) => number = (path, pairGrid, mazeGraph) => {\n  let distance: number = 0;\n  for (let i: number = 1; i < path.length; i++) {\n    let predNode: node = path[i - 1],\n      currNode: node = path[i];\n    let pred: [number, number] = pairGrid[predNode.x][predNode.y],\n      curr: [number, number] = pairGrid[currNode.x][currNode.y];\n    let neighbor: [[number, number], number] = ensure(\n      ensure(mazeGraph.get(pred)).find(\n        (neighborEdge) =>\n          neighborEdge[0][0] === curr[0] && neighborEdge[0][1] === curr[1]\n      )\n    );\n    distance += neighbor[1];\n  }\n  return distance;\n};\n","import { ensure } from \"../ensureNotUndefined\";\n\nexport class BinaryHeap<T> {\n  content: ([T, number] | undefined)[];\n  compare: (a: [T, number], b: [T, number]) => boolean;\n  index: number;\n\n  constructor(compare: (a: [T, number], b: [T, number]) => boolean) {\n    this.content = [];\n    this.index = 1;\n    this.compare = compare;\n  }\n\n  push(element: T) {\n    this.content.push([element, this.index++]);\n    this.bubbleUp(this.content.length - 1);\n  }\n\n  pop(): T | undefined {\n    let result: [T, number] = ensure(this.content[0]);\n    let end: [T, number] | undefined = this.content.pop();\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.sinkDown(0);\n    }\n    return ensure(result)[0];\n  }\n\n  remove(node: T) {\n    let length: number = this.content.length;\n    // To remove a value, we must search through the array to find\n    // it.\n    for (let i: number = 0; i < length; i++) {\n      if (ensure(this.content[i])[0] !== node) continue;\n      // When it is found, the process seen in 'pop' is repeated\n      // to fill up the hole.\n      let end: [T, number] | undefined = this.content.pop();\n      // If the element we popped was the one we needed to remove,\n      // we're done.\n      if (i === length - 1) break;\n      // Otherwise, we replace the removed element with the popped\n      // one, and allow it to float up or sink down as appropriate.\n      this.content[i] = end;\n      this.bubbleUp(i);\n      this.sinkDown(i);\n      break;\n    }\n  }\n\n  size() {\n    return this.content.length;\n  }\n\n  private bubbleUp(n: number) {\n    // Fetch the element that has to be moved.\n    let element: [T, number] = ensure(this.content[n]);\n    // When at 0, an element can not go up any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      let parentN: number = Math.floor((n + 1) / 2) - 1,\n        parent: [T, number] = ensure(this.content[parentN]);\n      // If the parent has a lesser score, things are in order and we\n      // are done.\n      // if (\n      //   score > this.scoreFunction(ensure(parent)[0]) ||\n      //   (score === this.scoreFunction(ensure(parent)[0]) &&\n      //     ensure(element)[1] > ensure(parent)[1])\n      // )\n      //   break;\n      if (this.compare(parent, element)) break;\n\n      // Otherwise, swap the parent with the current element and\n      // continue.\n      this.content[parentN] = element;\n      this.content[n] = parent;\n      n = parentN;\n    }\n  }\n\n  private sinkDown(n: number) {\n    // Look up the target element and its score.\n    let length: number = this.content.length,\n      element: [T, number] = ensure(this.content[n]);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      let child2N: number = (n + 1) * 2,\n        child1N: number = child2N - 1;\n      let swap: number = n;\n      // This is used to store the new position of the element, if any.\n      // If the first child exists (is inside the array)...\n      if (\n        child1N < length &&\n        this.compare(ensure(this.content[child1N]), element)\n      )\n        swap = child1N;\n      if (\n        child2N < length &&\n        this.compare(ensure(this.content[child2N]), ensure(this.content[swap]))\n      )\n        swap = child2N;\n\n      // If the order is good, we exit the loop\n      if (swap === n) break;\n\n      // Otherwise, swap and continue.\n      this.content[n] = this.content[swap];\n      this.content[swap] = element;\n      n = swap;\n    }\n  }\n}\n","import { node } from \"../../usefulInterfaces\";\nimport { BinaryHeap } from \"../../dataStructures/binaryHeap\";\nimport { retrievePath } from \"../retrievePath\";\nimport { ensure } from \"../../ensureNotUndefined\";\n\nexport const dijkstraHelper: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetList: node[]\n) => [node[], node[], node, number] = (\n  grid,\n  pairGrid,\n  mazeGraph,\n  startNode,\n  oldTargetList\n) => {\n  const m = grid.length,\n    n = grid[0].length;\n  const targetList: node[] = oldTargetList.slice();\n  // Initialize the distances array\n  const distances: number[][] = [];\n  for (let i: number = 0; i < m; i++) {\n    distances.push([]);\n    for (let j: number = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER - 1);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  for (let i: number = 0; i < m * n; i++) {\n    predecessor.push(startNode);\n  }\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  //   Initialize the Binary Heap\n  let pq: BinaryHeap<node> = new BinaryHeap<node>(\n    (a: [node, number], b: [node, number]) => {\n      if (distances[a[0].x][a[0].y] !== distances[b[0].x][b[0].y]) {\n        return distances[a[0].x][a[0].y] < distances[b[0].x][b[0].y];\n      }\n      return a[1] < b[1];\n    }\n  );\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode: node = ensure(pq.pop());\n\n    // add the current node to the visited nodes\n    visited.push(currentNode);\n\n    // If we found the endNode, return the shortest path to it\n    if (targetList.find((targetNode) => targetNode === currentNode)) {\n      // Retrieve the shortest path\n      const shortestPath = retrievePath(predecessor, startNode, currentNode);\n      return [\n        visited,\n        shortestPath,\n        currentNode,\n        distances[currentNode.x][currentNode.y],\n      ];\n    }\n\n    // Get the coordinates of the nodes\n    let currentX: number = currentNode.x;\n    let currentY: number = currentNode.y;\n\n    // Iterate the neighbors of the node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentX][currentY])\n    )) {\n      // Get the coordinates of the neighbor node\n      let neighborX: number = neighbor[0][0],\n        neighborY: number = neighbor[0][1];\n\n      // Check if the coordinates are valid\n      if (neighborX < 0 || neighborX >= m || neighborY < 0 || neighborY >= n)\n        continue;\n\n      let nextNode: node = grid[neighborX][neighborY];\n\n      // Calculate the distance between the current node and the next node\n      // To Do: take into account the weight of the path\n      let currentDistance: number = distances[currentX][currentY] + neighbor[1];\n\n      // If the distance is less than the distance in the array distances,\n      // change it and change the predecessor of the next node to be the current one\n      if (currentDistance < distances[neighborX][neighborY]) {\n        predecessor[nextNode.id] = currentNode;\n        distances[neighborX][neighborY] = currentDistance;\n      }\n\n      // If the node is not yet visited, remove it from the heap and\n      // put it back in with its new distance as the score function\n      if (!visited.find((visitedNode) => visitedNode === nextNode)) {\n        pq.remove(nextNode);\n        pq.push(nextNode);\n      }\n    }\n  }\n  return [visited, [], startNode, 0];\n};\n\nexport const getDistanceMatrix: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  targetList: node[]\n) => number[][] = (grid, pairGrid, mazeGraph, targetList) => {\n  const result: number[][] = [];\n  for (let i: number = 0; i < targetList.length; i++) {\n    result.push([]);\n    for (let j: number = 0; j < targetList.length; j++) {\n      const distance = dijkstraHelper(\n        grid,\n        pairGrid,\n        mazeGraph,\n        targetList[i],\n        targetList.filter((targetNode: node) => targetNode === targetList[j])\n      )[3];\n      if (i !== j) result[i].push(distance);\n      else result[i].push(0);\n    }\n  }\n\n  return result;\n};\n\nexport const dijkstra: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetList: node[]\n) => [[node[], node[]], number] = (\n  grid,\n  pairGrid,\n  mazeGraph,\n  startNode,\n  targetList\n) => {\n  const [visited, path, , distance] = dijkstraHelper(\n    grid,\n    pairGrid,\n    mazeGraph,\n    startNode,\n    targetList\n  );\n  return [[visited, path], distance];\n};\n","import { node } from \"../../usefulInterfaces\";\nimport { BinaryHeap } from \"../../dataStructures/binaryHeap\";\nimport { retrievePath } from \"../retrievePath\";\nimport { ensure } from \"../../ensureNotUndefined\";\n\nexport const aStar: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetList: node[]\n) => [[node[], node[]], number] = (\n  grid,\n  pairGrid,\n  mazeGraph,\n  startNode,\n  targetList\n) => {\n  const m = grid.length,\n    n = grid[0].length;\n  const endNode: node = targetList[0];\n\n  // Initialize the distances array\n  const distances: number[][] = [];\n  for (let i: number = 0; i < m; i++) {\n    distances.push([]);\n    for (let j: number = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  for (let i: number = 0; i < m * n; i++) {\n    predecessor.push(startNode);\n  }\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  //   Initialize the Binary Heap\n  let pq: BinaryHeap<node> = new BinaryHeap<node>(\n    (a: [node, number], b: [node, number]) => {\n      let dA: number = manhattanDistance(a[0], endNode),\n        dB: number = manhattanDistance(b[0], endNode);\n      if (distances[a[0].x][a[0].y] + dA !== distances[b[0].x][b[0].y] + dB) {\n        return distances[a[0].x][a[0].y] + dA < distances[b[0].x][b[0].y] + dB;\n      }\n      return a[1] < b[1];\n    }\n  );\n\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode: node = ensure(pq.pop());\n\n    // add the current node to the visited nodes\n    visited.push(currentNode);\n\n    // If we found the endNode, return the shortest path to it\n    if (currentNode === endNode) {\n      // Retrieve the shortest path\n      const shortestPath = retrievePath(predecessor, startNode, endNode);\n      return [[visited, shortestPath], distances[endNode.x][endNode.y]];\n    }\n\n    // Get the coordinates of the nodes\n    let currentX: number = currentNode.x;\n    let currentY: number = currentNode.y;\n\n    // Iterate the neighbors of the node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentX][currentY])\n    )) {\n      // Get the coordinates of the neighbor node\n      let neighborX: number = neighbor[0][0],\n        neighborY: number = neighbor[0][1];\n\n      // Check if the coordinates are valid\n      if (neighborX < 0 || neighborX >= m || neighborY < 0 || neighborY >= n)\n        continue;\n\n      let nextNode: node = grid[neighborX][neighborY];\n\n      // Calculate the distance between the current node and the next node\n      let currentDistance: number = distances[currentX][currentY] + neighbor[1];\n\n      // If the distance is less than the distance in the array distances,\n      // change it and change the predecessor of the next node to be the current one\n      if (currentDistance < distances[neighborX][neighborY]) {\n        predecessor[nextNode.id] = currentNode;\n        distances[neighborX][neighborY] = currentDistance;\n      }\n\n      // If the node is not yet visited, remove it from the heap and\n      // put it back in with its new distance as the score function\n      if (!visited.find((visitedNode) => visitedNode === nextNode)) {\n        pq.remove(nextNode);\n        pq.push(nextNode);\n      }\n    }\n  }\n  return [[visited, []], 0];\n};\n\nconst manhattanDistance: (a: node, b: node) => number = (a, b) => {\n  return Math.abs(b.x - a.x) + Math.abs(b.y - a.y);\n};\n","import { node } from \"../../usefulInterfaces\";\nimport { dijkstraHelper } from \"../singleTarget/dijkstra\";\n\nexport const greedy: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetList: node[]\n) => [[node[], node[]][], number] = (\n  grid,\n  pairGrid,\n  mazeGraph,\n  startNode,\n  targetList\n) => {\n  let currentStartNode: node = startNode,\n    totalDistance: number = 0;\n  let allVisitedAndPaths: [node[], node[]][] = [];\n  while (targetList.length > 0) {\n    let [visited, path, endNode, distance] = dijkstraHelper(\n      grid,\n      pairGrid,\n      mazeGraph,\n      currentStartNode,\n      targetList.slice()\n    );\n    totalDistance += distance;\n    targetList = targetList.filter((targetNode) => targetNode !== endNode);\n    currentStartNode = endNode;\n    allVisitedAndPaths.push([visited, path]);\n  }\n  return [allVisitedAndPaths, totalDistance];\n};\n","import { node } from \"../../usefulInterfaces\";\nimport { dijkstra, getDistanceMatrix } from \"../singleTarget/dijkstra\";\nimport { greedy } from \"./greedy\";\n\nexport const bruteForceTSP: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetList: node[]\n) => [[node[], node[]][], number] = (\n  grid,\n  pairGrid,\n  mazeGraph,\n  startNode,\n  targetList\n) => {\n  const newTargetList: node[] = targetList.slice();\n  newTargetList.unshift(startNode);\n  const distancesMatrix: number[][] = getDistanceMatrix(\n    grid,\n    pairGrid,\n    mazeGraph,\n    newTargetList\n  );\n  let path: [node, number][] = [[startNode, 0]];\n  let optimalPath: [node, number][] = [];\n\n  let maxCost: number = greedy(\n    grid,\n    pairGrid,\n    mazeGraph,\n    startNode,\n    targetList\n  )[1];\n  const maxLength: number = targetList.length + 1;\n  const bnbtargets: [node, number][] = targetList.map((targetNode, i) => [\n    targetNode,\n    i + 1,\n  ]);\n\n  const branchAndBound: (\n    candidatePath: [node, number][],\n    remainingTargets: [node, number][],\n    currentCost: number\n  ) => void = (candidatePath, remainingTargets, currentCost) => {\n    if (candidatePath.length === maxLength) {\n      if (currentCost > maxCost) return;\n      maxCost = currentCost;\n      optimalPath = candidatePath;\n      return;\n    }\n    const newRemainingTargets: [node, number][] = remainingTargets.slice();\n    remainingTargets.forEach((targetNodeAndIndex) => {\n      let prevId: number = candidatePath[candidatePath.length - 1][1];\n      candidatePath.push(targetNodeAndIndex);\n      branchAndBound(\n        candidatePath.slice(),\n        newRemainingTargets.filter(\n          (tgAndId) => tgAndId[1] !== targetNodeAndIndex[1]\n        ),\n        currentCost + distancesMatrix[prevId][targetNodeAndIndex[1]]\n      );\n      candidatePath.pop();\n    });\n  };\n  branchAndBound(path, bnbtargets, 0);\n  console.log(optimalPath);\n  return [\n    getTrueOptimalPath(\n      grid,\n      pairGrid,\n      mazeGraph,\n      optimalPath.map((valueIndexPair) => valueIndexPair[0])\n    ),\n    maxCost,\n  ];\n};\n\nconst getTrueOptimalPath: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  optimalPath: node[]\n) => [node[], node[]][] = (grid, pairGrid, mazeGraph, optimalPath) => {\n  let actualPath: [node[], node[]][] = [];\n  for (let i: number = 0; i < optimalPath.length - 1; i++) {\n    let path = dijkstra(grid, pairGrid, mazeGraph, optimalPath[i], [\n      optimalPath[i + 1],\n    ])[0][1];\n    actualPath.push([[], path.slice()]);\n  }\n  return actualPath;\n};\n","import { node } from \"../usefulInterfaces\";\nimport { dfs } from \"./singleTarget/dfs\";\nimport { bfs } from \"./singleTarget/bfs\";\nimport { dijkstra } from \"./singleTarget/dijkstra\";\nimport { aStar } from \"./singleTarget/aStar\";\nimport { greedy } from \"./multipleTarget/greedy\";\nimport { bruteForceTSP } from \"./multipleTarget/bruteForce\";\nimport { twoEndedBfs } from \"./singleTarget/twoEndedBfs\";\n\nexport const singleTargetAlgorithms: {\n  [key: string]: (\n    grid: node[][],\n    pairGrid: [number, number][][],\n    mazeGraph: Map<[number, number], [[number, number], number][]>,\n    startNode: node,\n    targetList: node[]\n  ) => [[node[], node[]], number];\n} = {\n  \"Depth First Search\": dfs,\n  \"Breadth First Search\": bfs,\n  \"Dijkstra's algorithm\": dijkstra,\n  \"A* algorithm\": aStar,\n  \"Meet in the Middle BFS\": twoEndedBfs,\n};\n\nexport const multipleTargetsAlgorithms: {\n  [key: string]: (\n    grid: node[][],\n    pairGrid: [number, number][][],\n    mazeGraph: Map<[number, number], [[number, number], number][]>,\n    startNode: node,\n    targetList: node[]\n  ) => [[node[], node[]][], number];\n} = {\n  \"Nearest Neighbors Heuristic\": greedy,\n  \"Brute Force Algorithm\": bruteForceTSP,\n};\n","import { node } from \"../../usefulInterfaces\";\nimport { retrieveDistance, retrievePath } from \"../retrievePath\";\nimport { ensure } from \"../../ensureNotUndefined\";\n\nexport const dfs: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetList: node[]\n) => [[node[], node[]], number] = (\n  grid,\n  pairGrid,\n  mazeGraph,\n  startNode,\n  targetList\n) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  for (let i: number = 0; i < m * n; i++) {\n    predecessor.push(startNode);\n  }\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  // Discovered array\n  let discovered: node[] = [startNode];\n\n  // Initialize the stack\n  let stack: node[] = [startNode];\n\n  // While the stack is not empty\n  while (stack.length > 0) {\n    // Get the element in front of the stack\n    let currentNode: node = ensure(stack.pop());\n\n    if (visited.find((visitedNode) => visitedNode === currentNode)) continue;\n\n    // Put the currentNode node in the visited set\n    visited.push(currentNode);\n\n    // If we found the end node, return the path to it\n    if (targetList.find((targetNode) => currentNode === targetNode)) {\n      // Retrieve the shortest path\n      const shortestPath = retrievePath(predecessor, startNode, currentNode);\n      return [\n        [visited, shortestPath],\n        retrieveDistance(shortestPath, pairGrid, mazeGraph),\n      ];\n    }\n\n    // iterate through the neighbors of the currentNode node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentNode.x][currentNode.y])\n    )) {\n      // Get the coordinates of the neighbor node\n      let neighborX: number = neighbor[0][0],\n        neighborY: number = neighbor[0][1];\n\n      // Check if the node is on the board\n      if (\n        neighborX < 0 ||\n        neighborX >= m ||\n        neighborY < 0 ||\n        neighborY >= n ||\n        discovered.find(\n          (discoveredNode) => discoveredNode === grid[neighborX][neighborY]\n        )\n      )\n        continue;\n\n      // Get the node in the grid\n      let nextNode: node = grid[neighborX][neighborY];\n\n      // update the predecessor array\n      predecessor[nextNode.id] = currentNode;\n\n      // Add the node to the discovered array\n      discovered.push(nextNode);\n\n      // Push the nextNode to the stack\n      stack.push(nextNode);\n    }\n  }\n\n  return [[visited, []], 0];\n};\n","import { node } from \"../../usefulInterfaces\";\nimport { retrieveDistance, retrievePath } from \"../retrievePath\";\nimport { ensure } from \"../../ensureNotUndefined\";\n\nexport const bfs: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetList: node[]\n) => [[node[], node[]], number] = (\n  grid,\n  pairGrid,\n  mazeGraph,\n  startNode,\n  targetList\n) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  for (let i: number = 0; i < m * n; i++) {\n    predecessor.push(startNode);\n  }\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  // Initialize the discovered array\n  let discovered: node[] = [startNode];\n\n  // Initialize the Queue TODO: IMPLEMENT A BETTER VERSION OF THE QUEUE WITH O(1) OPERATIONS\n  let q: node[] = [startNode];\n\n  // While the queue is not empty\n  while (q.length > 0) {\n    // Get the element in front of the queue\n    let currentNode: node = ensure(q.shift());\n\n    if (visited.find((visitedNode) => visitedNode === currentNode)) continue;\n\n    // Put the currentNode node in the visited set\n    visited.push(currentNode);\n\n    // If we found the end node, return the path to it\n    if (targetList.find((targetNode) => currentNode === targetNode)) {\n      // Retrieve the shortest path\n      const shortestPath = retrievePath(predecessor, startNode, currentNode);\n      return [\n        [visited, shortestPath],\n        retrieveDistance(shortestPath, pairGrid, mazeGraph),\n      ];\n    }\n\n    // iterate through the neighbors of the currentNode node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentNode.x][currentNode.y])\n    )) {\n      // Get the coordinates of the neighbor node\n      let neighborX: number = neighbor[0][0],\n        neighborY: number = neighbor[0][1];\n\n      if (\n        neighborX < 0 ||\n        neighborX >= m ||\n        neighborY < 0 ||\n        neighborY >= n ||\n        discovered.find(\n          (discoveredNode) => discoveredNode === grid[neighborX][neighborY]\n        )\n      )\n        continue;\n\n      // Get the node in the grid\n      let nextNode: node = grid[neighborX][neighborY];\n\n      // update the predecessor array\n      predecessor[nextNode.id] = currentNode;\n\n      // Add the node to the visited nodes\n      discovered.push(nextNode);\n\n      // Push the next node to the queue\n      q.push(nextNode);\n    }\n  }\n\n  return [[visited, []], 0];\n};\n","import { node } from \"../../usefulInterfaces\";\nimport { retrieveDistance, retrieveTwoEndedPath } from \"../retrievePath\";\nimport { ensure } from \"../../ensureNotUndefined\";\n\nexport const twoEndedBfs: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetList: node[]\n) => [[node[], node[]], number] = (\n  grid,\n  pairGrid,\n  mazeGraph,\n  startNode,\n  targetList\n) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  for (let i: number = 0; i < m * n; i++) {\n    predecessor.push(startNode);\n  }\n  predecessor[startNode.id] = startNode;\n\n  const successor: node[] = [];\n  for (let i: number = 0; i < m * n; i++) {\n    successor.push(targetList[0]);\n  }\n  successor[targetList[0].id] = targetList[0];\n\n  const source: node[] = [];\n  for (let i: number = 0; i < m * n; i++) {\n    source.push(targetList[0]);\n  }\n  source[startNode.id] = startNode;\n  source[targetList[0].id] = targetList[0];\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  // Initialize the discovered array\n  let discovered: node[] = [startNode, targetList[0]];\n\n  // Initialize the Queue TODO: IMPLEMENT A BETTER VERSION OF THE QUEUE WITH O(1) OPERATIONS\n  let q: node[] = [startNode, targetList[0]];\n\n  // While the queue is not empty\n  while (q.length > 0) {\n    // Get the element in front of the queue\n    let currentNode: node = ensure(q.shift());\n\n    if (visited.find((visitedNode) => visitedNode === currentNode)) continue;\n\n    // Put the currentNode node in the visited set\n    visited.push(currentNode);\n\n    // iterate through the neighbors of the currentNode node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentNode.x][currentNode.y])\n    )) {\n      // Get the coordinates of the neighbor node\n      let neighborX: number = neighbor[0][0],\n        neighborY: number = neighbor[0][1];\n\n      if (neighborX < 0 || neighborX >= m || neighborY < 0 || neighborY >= n)\n        continue;\n\n      // Get the node in the grid\n      let nextNode: node = grid[neighborX][neighborY];\n\n      // Store the result of the find function for later\n      const foundNode: node | undefined = visited.find(\n        (visitedNode) => visitedNode === nextNode\n      );\n\n      // If we found the end node, return the path to it\n      if (foundNode && source[currentNode.id] !== source[foundNode.id]) {\n        if (source[currentNode.id] === startNode)\n          predecessor[nextNode.id] = currentNode;\n        else successor[nextNode.id] = currentNode;\n        // Retrieve the shortest path\n        const shortestPath = retrieveTwoEndedPath(\n          predecessor,\n          successor,\n          nextNode,\n          startNode,\n          targetList[0]\n        );\n        return [\n          [visited, shortestPath],\n          retrieveDistance(shortestPath, pairGrid, mazeGraph),\n        ];\n      }\n\n      if (\n        discovered.find(\n          (discoveredNode) => discoveredNode === grid[neighborX][neighborY]\n        )\n      )\n        continue;\n\n      source[nextNode.id] = source[currentNode.id];\n\n      if (source[currentNode.id] === startNode) {\n        // update the predecessor array\n        predecessor[nextNode.id] = currentNode;\n      } else {\n        successor[nextNode.id] = currentNode;\n      }\n\n      // Add the node to the visited nodes\n      discovered.push(nextNode);\n\n      // Push the next node to the queue\n      q.push(nextNode);\n    }\n  }\n\n  return [[visited, []], 0];\n};\n","import { ensure } from \"../ensureNotUndefined\";\nimport { node } from \"../usefulInterfaces\";\n\nconst createMazeGraph: (\n  rowLength: number,\n  columnLength: number,\n  grid: node[][]\n) => [\n  [number, number][][],\n  Map<[number, number], [[number, number], number][]>\n] = (rowLength, columnLength, grid) => {\n  let pairGrid: [number, number][][] = [];\n  for (let i: number = 0; i < columnLength; i++) {\n    let pairRow: [number, number][] = [];\n    for (let j: number = 0; j < rowLength; j++) {\n      let currentNode: node = grid[i][j];\n      pairRow.push([currentNode.x, currentNode.y]);\n    }\n    pairGrid.push(pairRow);\n  }\n\n  // Create the maze graph\n  let mazeGraph: Map<\n    [number, number],\n    [[number, number], number][]\n  > = new Map();\n  for (let i: number = 0; i < columnLength; i++) {\n    for (let j: number = 0; j < rowLength; j++) {\n      mazeGraph.set(pairGrid[i][j], []);\n    }\n  }\n\n  return [pairGrid, mazeGraph];\n};\n\nexport const createEmptyMazeGraph: (\n  rowLength: number,\n  columnLength: number,\n  grid: node[][]\n) => [[number, number][][], Map<[number, number], [number, number][]>] = (\n  rowLength,\n  columnLength,\n  grid\n) => {\n  let pairGrid: [number, number][][] = [];\n  for (let i: number = 0; i < columnLength; i++) {\n    let pairRow: [number, number][] = [];\n    for (let j: number = 0; j < rowLength; j++) {\n      let currentNode: node = grid[i][j];\n      pairRow.push([currentNode.x, currentNode.y]);\n    }\n    pairGrid.push(pairRow);\n  }\n  // Create the maze graph\n  let mazeGraph: Map<[number, number], [number, number][]> = new Map();\n  for (let i: number = 0; i < columnLength; i++) {\n    for (let j: number = 0; j < rowLength; j++) {\n      let neighbors: [number, number][] = getNeighborsEmpty(\n        pairGrid,\n        [i, j],\n        columnLength,\n        rowLength\n      );\n\n      mazeGraph.set(pairGrid[i][j], neighbors);\n    }\n  }\n  return [pairGrid, mazeGraph];\n};\n\nexport const generateMazeGraph: (\n  rowLength: number,\n  columnLength: number,\n  grid: node[][],\n  wallsDensity: number,\n  mudDendity: number,\n  mudWeigth: number\n) => [\n  [number, number][][],\n  Map<[number, number], [[number, number], number][]>\n] = (rowLength, columnLength, grid, wallsDensity, mudDensity, mudWeight) => {\n  const MUD_WEIGHT = mudWeight;\n\n  let [pairGrid, mazeGraph]: [\n    [number, number][][],\n    Map<[number, number], [[number, number], number][]>\n  ] = createMazeGraph(rowLength, columnLength, grid);\n\n  let currentWallsCount: number =\n      2 * (rowLength - 1) * (columnLength - 1) + rowLength + columnLength - 2,\n    maxWallsOrMud = currentWallsCount;\n\n  // I. Generate a maze where each cells is reachable (with a DFS)\n\n  // 1. Choose the initial cell, mark it as visited and push it to the stack\n  let startNode: [number, number] = pairGrid[0][0];\n  let stack: [number, number][] = [startNode];\n  let visited: [number, number][] = [startNode];\n\n  // 2. While the stack is not empty\n  while (stack.length > 0) {\n    // 1. Pop a cell from the stack and make it a current cell\n    let currentNode: [number, number] = ensure(stack.pop());\n    let currentNonVisitedNeighbors: [number, number][] = getNeighbors(\n      pairGrid,\n      currentNode,\n      rowLength,\n      columnLength,\n      visited\n    );\n    // 2. If the current cell has any neighbours which have not been visited\n    if (currentNonVisitedNeighbors.length > 0) {\n      // 1. Push the current cell to the stack\n      stack.push(currentNode);\n\n      // 2. Choose one of the unvisited neighbours\n      let randIndex: number = Math.floor(\n        Math.random() * currentNonVisitedNeighbors.length\n      );\n      let neighborNode: [number, number] =\n        currentNonVisitedNeighbors[randIndex];\n\n      // 3. Remove the wall between the current cell and the chosen cell\n      let currentNodeNeighbors: [[number, number], number][] = ensure(\n        mazeGraph.get(currentNode)\n      );\n      currentNodeNeighbors.push([neighborNode, 1]);\n\n      let neighborNodeNeighbors: [[number, number], number][] = ensure(\n        mazeGraph.get(neighborNode)\n      );\n      neighborNodeNeighbors.push([currentNode, 1]);\n\n      // 4. Mark the ch// mazeGraph.set(neighborNode, neighborNodeNeighbors);osen cell as visited and push it to the stack\n      visited.push(neighborNode);\n      stack.push(neighborNode);\n\n      // 5. Remove 1 from the currentWallsCount\n      currentWallsCount--;\n    }\n  }\n\n  // II. Remove walls until the desired density is achieved\n  let maxWallsCount: number = currentWallsCount;\n  while (currentWallsCount * (1 / maxWallsCount) > wallsDensity) {\n    // 1. Choose a node randomly\n    let randRow: number = Math.floor(Math.random() * rowLength);\n    let randCol: number = Math.floor(Math.random() * columnLength);\n    let currentNode: [number, number] = pairGrid[randCol][randRow];\n\n    // 2. Get the cells with a wall with the current cell\n    let neighbors: [number, number][] = getWalledOffNeighbors(\n      pairGrid,\n      currentNode,\n      rowLength,\n      columnLength,\n      mazeGraph\n    );\n\n    if (neighbors.length > 0) {\n      // 3. Choose one of the cells with a wall\n      let randIndex: number = Math.floor(Math.random() * neighbors.length);\n      let neighborNode: [number, number] =\n        pairGrid[neighbors[randIndex][0]][neighbors[randIndex][1]];\n\n      // 4. Remove the wall between the 2 cells\n      let currentNodeNeighbors: [[number, number], number][] = ensure(\n        mazeGraph.get(currentNode)\n      );\n      currentNodeNeighbors.push([neighborNode, 1]);\n\n      let neighborNodeNeighbors: [[number, number], number][] = ensure(\n        mazeGraph.get(neighborNode)\n      );\n      neighborNodeNeighbors.push([currentNode, 1]);\n\n      currentWallsCount--;\n    }\n  }\n\n  // III. Add mud to the graph until we get the desired mud density\n  let currentMud: number = 0,\n    maxMud: number = maxWallsOrMud - currentWallsCount;\n  while (currentMud * (1 / maxMud) < mudDensity) {\n    // 1. Choose a node randomly\n    let randRow: number = Math.floor(Math.random() * rowLength);\n    let randCol: number = Math.floor(Math.random() * columnLength);\n    let currentNode: [number, number] = pairGrid[randCol][randRow];\n\n    // 2. Get the neighbors than have no mud\n    let neighbors: [[number, number], number][] = ensure(\n      mazeGraph.get(currentNode)\n    ).filter((item: [[number, number], number]) => item[1] === 1);\n\n    if (neighbors.length > 0) {\n      // 3. Get a random neighbor\n      let randIndex: number = Math.floor(Math.random() * neighbors.length);\n      let neighborNode: [number, number] =\n        pairGrid[neighbors[randIndex][0][0]][neighbors[randIndex][0][1]];\n\n      neighbors[randIndex][1] = MUD_WEIGHT;\n\n      let neighborNodeNeighbors: [[number, number], number][] = ensure(\n        mazeGraph.get(neighborNode)\n      );\n      let currentNodeAndDistance: [[number, number], number] = ensure(\n        neighborNodeNeighbors.find(\n          (item: [[number, number], number]) => item[0] === currentNode\n        )\n      );\n      currentNodeAndDistance[1] = MUD_WEIGHT;\n      currentMud++;\n    }\n  }\n  return [pairGrid, mazeGraph];\n};\n\nconst getNeighbors: (\n  grid: [number, number][][],\n  currentNode: [number, number],\n  rowLength: number,\n  columnLength: number,\n  visited: [number, number][]\n) => [number, number][] = (\n  pairGrid,\n  currentNode,\n  rowLength,\n  columnLength,\n  visited\n) => {\n  const directions = [\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n    [0, 1],\n  ];\n\n  let neighbors: [number, number][] = [];\n  let neighborX: number = -1;\n  let neighborY: number = -1;\n\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n    if (\n      neighborX >= 0 &&\n      neighborX < columnLength &&\n      neighborY >= 0 &&\n      neighborY < rowLength &&\n      !visited.includes(pairGrid[neighborX][neighborY])\n    ) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n  return neighbors;\n};\n\nexport const getNeighborsEmpty: (\n  pairGrid: [number, number][][],\n  currentNode: [number, number],\n  columnLength: number,\n  rowLength: number\n) => [number, number][] = (pairGrid, currentNode, columnLength, rowLength) => {\n  const directions = [\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n    [0, 1],\n  ];\n\n  let neighbors: [number, number][] = [];\n  let neighborX: number = -1;\n  let neighborY: number = -1;\n\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n    if (\n      neighborX >= 0 &&\n      neighborX < columnLength &&\n      neighborY >= 0 &&\n      neighborY < rowLength\n    ) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n  return neighbors;\n};\n\n// This function returns the neighbors which have a wall with the current node\nconst getWalledOffNeighbors: (\n  pairGrid: [number, number][][],\n  currentNode: [number, number],\n  rowLength: number,\n  columnLength: number,\n  mazeGraph: Map<[number, number], [[number, number], number][]>\n) => [number, number][] = (\n  pairGrid,\n  currentNode,\n  rowLength,\n  columnLength,\n  mazeGraph\n) => {\n  const directions = [\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n    [0, 1],\n  ];\n\n  let neighbors: [number, number][] = [];\n  let neighborX: number = -1;\n  let neighborY: number = -1;\n\n  const findCallback: (neighbor: [[number, number], number]) => boolean = (\n    neighbor\n  ) => {\n    return neighbor[0] === pairGrid[neighborX][neighborY];\n  };\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n\n    if (\n      neighborX >= 0 &&\n      neighborX < columnLength &&\n      neighborY >= 0 &&\n      neighborY < rowLength &&\n      // !mazeGraph.get(currentNode)?.includes(pairGrid[neighborX][neighborY])\n      !mazeGraph.get(currentNode)?.find(findCallback)\n    ) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n  return neighbors;\n};\n","import { node } from \"./usefulInterfaces\";\n\n// This function (Not a React Component!) is made to initialize the grid rendered in the App component.\nexport const constructGrid: (\n  numberOfRows: number,\n  numberOfColumn: number,\n  startNode: [number, number],\n  endNode: [number, number],\n  numberOfTargets: number\n) => [node[][], node, node[]] = (\n  numberOfRow,\n  numberOfColumn,\n  startNode,\n  endNode,\n  numberOfTargets\n) => {\n  let result: node[][] = [];\n  for (let i: number = 0; i < numberOfColumn; i++) {\n    let currentRow: node[] = [];\n    for (let j: number = 0; j < numberOfRow; j++) {\n      let currentNode: node = {\n        id: i + j * numberOfColumn,\n        x: i,\n        y: j,\n        isStart: false,\n        hasCheese: false,\n        hasRat: false,\n        isVisited: false,\n        isShortestPath: false,\n        successorPosition: \"\",\n      };\n      currentRow.push(currentNode);\n    }\n    result.push(currentRow);\n  }\n  result[startNode[0]][startNode[1]].isStart = true;\n  result[startNode[0]][startNode[1]].hasRat = true;\n  result[endNode[0]][endNode[1]].hasCheese = true;\n  let targetList: node[] = [result[endNode[0]][endNode[1]]];\n  if (numberOfTargets >= 1)\n    [result, targetList] = piecesOfCheese(\n      result,\n      startNode,\n      endNode,\n      numberOfTargets\n    );\n  return [result, result[startNode[0]][startNode[1]], targetList];\n};\n\nexport const reconstructGrid: (\n  numberOfRows: number,\n  numberOfColumn: number,\n  startNode: [number, number],\n  targetList: node[]\n) => [node[][], node, node[]] = (\n  numberOfRow,\n  numberOfColumn,\n  startNode,\n  targetList\n) => {\n  let result: node[][] = [];\n  for (let i: number = 0; i < numberOfColumn; i++) {\n    let currentRow: node[] = [];\n    for (let j: number = 0; j < numberOfRow; j++) {\n      let currentNode: node = {\n        id: i + j * numberOfColumn,\n        x: i,\n        y: j,\n        isStart: false,\n        hasCheese: targetList.find(\n          (targetNode) => targetNode.x === i && targetNode.y === j\n        )\n          ? true\n          : false,\n        hasRat: false,\n        isVisited: false,\n        isShortestPath: false,\n        successorPosition: \"\",\n      };\n      currentRow.push(currentNode);\n    }\n    result.push(currentRow);\n  }\n  result[startNode[0]][startNode[1]].isStart = true;\n  result[startNode[0]][startNode[1]].hasRat = true;\n  let newTargetList: node[] = targetList.map(\n    (targetNode) => result[targetNode.x][targetNode.y]\n  );\n  return [result, result[startNode[0]][startNode[1]], newTargetList];\n};\n\nconst piecesOfCheese: (\n  grid: node[][],\n  startNode: [number, number],\n  endNode: [number, number],\n  cheeseNum: number\n) => [node[][], node[]] = (grid, startNode, endNode, cheeseNum) => {\n  const n: number = grid.length,\n    m: number = grid[0].length;\n  const targetList: node[] = [grid[endNode[0]][endNode[1]]];\n  let visited: boolean[][] = new Array(n);\n  for (let i: number = 0; i < n; ++i) {\n    visited[i] = new Array(m);\n  }\n  for (let i: number = 0; i < n; ++i) {\n    for (let j: number = 0; j < m; ++j) {\n      visited[i][j] = false;\n    }\n  }\n\n  visited[startNode[0]][startNode[1]] = true;\n  visited[endNode[0]][endNode[1]] = true;\n  for (let k: number = 0; k < cheeseNum; k++) {\n    let i = -1,\n      j = -1;\n    do {\n      i = Math.floor(Math.random() * n);\n      j = Math.floor(Math.random() * m);\n    } while (visited[i][j]);\n    visited[i][j] = true;\n    grid[i][j].hasCheese = true;\n    targetList.push(grid[i][j]);\n  }\n  return [grid, targetList];\n};\n\nexport const addPiecesOfCheese: (\n  numberOfRows: number,\n  numberOfColumn: number,\n  startNode: node,\n  oldTargetList: node[],\n  cheeseToAdd: number\n) => [node[][], node, node[]] = (\n  numberOfRows,\n  numberOfColumn,\n  startNode,\n  oldTargetList,\n  cheeseToAdd\n) => {\n  // let targetList: node[] = [];\n  while (cheeseToAdd < 0) {\n    let randIndex: number = Math.floor(Math.random() * oldTargetList.length);\n    oldTargetList = oldTargetList.filter(\n      (targetNode, index) => index !== randIndex\n    );\n    cheeseToAdd++;\n  }\n\n  const [newGrid, newStartNode, targetList] = reconstructGrid(\n    numberOfRows,\n    numberOfColumn,\n    [startNode.x, startNode.y],\n    oldTargetList\n  );\n\n  let visited: boolean[][] = new Array(numberOfColumn);\n  for (let i: number = 0; i < numberOfColumn; ++i) {\n    visited[i] = new Array(numberOfRows);\n  }\n  for (let i: number = 0; i < numberOfColumn; ++i) {\n    for (let j: number = 0; j < numberOfRows; ++j) {\n      visited[i][j] = false;\n    }\n  }\n\n  visited[startNode.x][startNode.y] = true;\n  targetList.forEach((targetNode) => {\n    visited[targetNode.x][targetNode.y] = true;\n  });\n  for (let k: number = 0; k < cheeseToAdd; k++) {\n    let i = -1,\n      j = -1;\n    do {\n      i = Math.floor(Math.random() * numberOfColumn);\n      j = Math.floor(Math.random() * numberOfRows);\n    } while (visited[i][j]);\n    visited[i][j] = true;\n    newGrid[i][j].hasCheese = true;\n    targetList.push(newGrid[i][j]);\n  }\n  return [newGrid, newStartNode, targetList];\n};\n","import React, { useRef } from \"react\";\nimport { CSSTransition } from \"react-transition-group\";\n\ninterface WrapperProps {\n  handleEnter: any;\n  timeout: number;\n  classNames: string;\n  in: boolean;\n  unmountOnExit: boolean;\n  divClassName: string;\n  appear?: boolean;\n}\n\nexport const WrapperCSSTransition: React.FC<WrapperProps> = ({\n  handleEnter,\n  divClassName,\n  ...props\n}) => {\n  const nodeRef = useRef<HTMLDivElement>(null);\n\n  // This function calculates the height of a DOM element\n  const calcHeight: (isAppearing: boolean) => void = (isAppearing) => {\n    const el = nodeRef.current;\n    const height: number = el !== null ? el.offsetHeight : 0;\n    handleEnter(height);\n  };\n\n  return (\n    <CSSTransition nodeRef={nodeRef} {...props} onEnter={calcHeight}>\n      <div className={divClassName} ref={nodeRef}>\n        {props.children}\n      </div>\n    </CSSTransition>\n  );\n};\n","import React, { useState } from \"react\";\nimport { WrapperCSSTransition } from \"../Wrapper/Wrapper\";\nimport \"./Tutorial.css\";\n\ninterface TutorialProps {\n  handleDismiss: () => void;\n  showTutorial: boolean;\n}\n\nexport const Tutorial: React.FC<TutorialProps> = (props) => {\n  const [activePage, setActivePage] = useState(\"first-page\");\n  return (\n    <div className={\"tutorial-panel \" + (props.showTutorial ? \"\" : \"hide\")}>\n      <WrapperCSSTransition\n        in={activePage === \"first-page\"}\n        unmountOnExit\n        timeout={500}\n        classNames=\"page-container\"\n        divClassName={\"first-page page\"}\n        handleEnter={() => {}}\n      >\n        <Page\n          leftButton={false}\n          rightButton={true}\n          rightOnClick={() => setActivePage(\"second-page\")}\n          handleDismiss={props.handleDismiss}\n        >\n          <h1 className=\"big-title\">\n            Welcome to the \"Rat in a maze\" Pathfinding Visualizing tool!\n          </h1>\n          <div className=\"emoji-container\">\n            <span role=\"img\" aria-label=\"rat\" className=\"tutorial-emoji\">\n              \n            </span>\n            <span role=\"img\" aria-label=\"cheese\" className=\"tutorial-emoji\">\n              \n            </span>\n          </div>\n\n          <h3 className=\"text\">\n            This is a tool I built to learn more about graph algorithm, and\n            particularly Pathfinding Algorithms. There are some cool features\n            implemented.\n          </h3>\n          <span className=\"how-to-dismiss\">\n            <h3>\n              You can skip this tutorial by clicking on \"Dismiss\". You can\n              reopen this tutorial by click on the \"i\" button on the top-right\n              corner of the grid.\n            </h3>\n            <img\n              className=\"img\"\n              alt=\"bouton informations\"\n              src={require(\"./imagesAndGifs/infoButton.png\")}\n            ></img>\n          </span>\n          <h2>So without further ado, let's see how it works!</h2>\n        </Page>\n      </WrapperCSSTransition>\n      <WrapperCSSTransition\n        in={activePage === \"second-page\"}\n        unmountOnExit\n        timeout={750}\n        classNames=\"page-container\"\n        divClassName={\"second-page page\"}\n        handleEnter={() => {}}\n      >\n        <Page\n          leftButton\n          rightButton\n          leftOnClick={() => setActivePage(\"first-page\")}\n          rightOnClick={() => setActivePage(\"third-page\")}\n          handleDismiss={props.handleDismiss}\n        >\n          <h1 className=\"big-title\">The Maze</h1>\n\n          <h3 className=\"text\">\n            The maze is composed of squares. Each square is linked to the\n            adjacent squares (left, right, top and bottom). The rat in the maze\n            is hungry, and it wants to eat all the cheese there is! To do that\n            it need to move in the maze. Each move costs 1 point of energy. The\n            goal of the rat is to minimize the energy points it will use to eat\n            all the cheese. But the maze is full of obstacles!\n          </h3>\n          <h3>\n            The first obstacles are the walls, represented by the thin black\n            lines. The rat cannot go through these.\n          </h3>\n          <img\n            src={require(\"./imagesAndGifs/wall.png\")}\n            alt=\"The walls of the maze\"\n            className=\"img img-wall\"\n          ></img>\n          <h3>\n            The second obstacles are the mud. The mud is different from the\n            walls: the rat can go through the mud but it will cost more energy\n            than moving through nothing. A normal move costs 1 energy point, a\n            move through the mud costs 4 energy points. This is what I call the\n            \"mud weight\".\n          </h3>\n          <img\n            src={require(\"./imagesAndGifs/mud.png\")}\n            alt=\"The light brown mud in the maze\"\n            className=\"img img-mud\"\n          ></img>\n        </Page>\n      </WrapperCSSTransition>\n      <WrapperCSSTransition\n        in={activePage === \"third-page\"}\n        unmountOnExit\n        timeout={750}\n        classNames=\"page-container\"\n        divClassName={\"third-page page\"}\n        handleEnter={() => {}}\n      >\n        <Page\n          leftButton\n          rightButton\n          leftOnClick={() => setActivePage(\"second-page\")}\n          rightOnClick={() => setActivePage(\"fourth-page\")}\n          handleDismiss={props.handleDismiss}\n        >\n          <h1 className=\"big-title\">The Algorithms</h1>\n          <h3>\n            To help the rat find its way through the maze you will have to run\n            some algorithms, and visualize them.\n          </h3>\n          <h3>\n            For a single cheese (or target), there are 2 types of algorithms:\n          </h3>\n          <ul>\n            <li>\n              <h3>\n                The algorithms for unweighted graphs, which will find a way to\n                the cheese while ignoring the added cost of going through mud\n                (these will not guarantee the shortest path),\n              </h3>\n            </li>\n            <li>\n              <h3>\n                And the algorithms for weighted graphs, which will take into\n                account the added cost of going through mud. In this tool, the\n                algorithms implemented will always find the shortest path\n                between the rat and the cheese (or the path of lowest energy\n                cost).\n              </h3>\n            </li>\n          </ul>\n\n          <h3>\n            In the case where there are several cheeses, there are 2 possible\n            algorithms in this tool:\n          </h3>\n          <ul>\n            <li>\n              <h3>\n                The brute force algorithm, that will find the optimal solution,\n                at the cost of a lot of computations,\n              </h3>\n            </li>\n            <li>\n              <h3>\n                And the nearest neighbors heuristic algorithm which will find a\n                solution a lot faster, but the solution may not be optimal.\n              </h3>\n            </li>\n          </ul>\n        </Page>\n      </WrapperCSSTransition>\n      <WrapperCSSTransition\n        in={activePage === \"fourth-page\"}\n        unmountOnExit\n        timeout={750}\n        classNames=\"page-container\"\n        divClassName={\"fourth-page page\"}\n        handleEnter={() => {}}\n      >\n        <Page\n          leftButton\n          rightButton\n          leftOnClick={() => setActivePage(\"third-page\")}\n          rightOnClick={() => setActivePage(\"fifth-page\")}\n          handleDismiss={props.handleDismiss}\n        >\n          <h1 className=\"big-title\">Choosing the Algorithm</h1>\n\n          <h3 className=\"text\">\n            You can enable multiple targets in the maze by clicking on the\n            button on the top-right corner, and then choose the number of\n            targets.\n          </h3>\n          <img\n            src={require(\"./imagesAndGifs/enableMultipleTargets.gif\")}\n            alt=\"enable multiple targets button\"\n            className=\"gif gif-multiple-targets\"\n          ></img>\n          <h3>\n            You can choose which algorithm you want to run on the dropdown menu\n            labeled \"Algorithms\".\n          </h3>\n          <img\n            src={require(\"./imagesAndGifs/chooseAlgorithm.gif\")}\n            alt=\"The dropdown menu of the algorithms\"\n            className=\"gif gif-choose-algorithm\"\n          ></img>\n          <h3>\n            Then you can run the visualization with the light blue \"Visualize\"\n            button!\n          </h3>\n        </Page>\n      </WrapperCSSTransition>\n      <WrapperCSSTransition\n        in={activePage === \"fifth-page\"}\n        unmountOnExit\n        timeout={750}\n        classNames=\"page-container\"\n        divClassName={\"fifth-page page\"}\n        handleEnter={() => {}}\n      >\n        <Page\n          leftButton\n          rightButton\n          leftOnClick={() => setActivePage(\"fourth-page\")}\n          rightOnClick={() => setActivePage(\"sixth-page\")}\n          handleDismiss={props.handleDismiss}\n        >\n          <h1 className=\"big-title\">Maze Generator</h1>\n\n          <h3 className=\"text\">\n            You can choose different options regarding the maze in the dropdown\n            menu labeled \"Maze Options\". You can also choose to hide the \"mud\n            weight\" if you want. <br />\n            Then you can generate a new maze with the changed values with the\n            \"Generate Maze button\".\n          </h3>\n          <img\n            src={require(\"./imagesAndGifs/mazeOptions.gif\")}\n            alt=\"The dropdown menu of maze options\"\n            className=\"gif gif-maze-options\"\n          ></img>\n        </Page>\n      </WrapperCSSTransition>\n      <WrapperCSSTransition\n        in={activePage === \"sixth-page\"}\n        unmountOnExit\n        timeout={750}\n        classNames=\"page-container\"\n        divClassName={\"sixth-page page\"}\n        handleEnter={() => {}}\n      >\n        <Page\n          leftButton\n          rightButton\n          leftOnClick={() => setActivePage(\"fifth-page\")}\n          rightOnClick={() => setActivePage(\"seventh-page\")}\n          handleDismiss={props.handleDismiss}\n        >\n          <h1 className=\"big-title\">The Rat and the cheeses</h1>\n\n          <h3 className=\"text\">\n            The last thing you need to know is that you can move the rat and the\n            cheese around before visualizing an algorithm! You have to click on\n            the rat and hold down the mouse button while moving, and releasing\n            the mouse button on the square you want the rat to be on (this is\n            essentially like a drag and drop action). The same thing works on\n            the cheeses too!\n          </h3>\n          <img\n            src={require(\"./imagesAndGifs/dragAndDrop.gif\")}\n            alt=\"Demonstration of the drag and drop\"\n            className=\"gif gif-drag-and-drop\"\n          ></img>\n        </Page>\n      </WrapperCSSTransition>\n      <WrapperCSSTransition\n        in={activePage === \"seventh-page\"}\n        unmountOnExit\n        timeout={750}\n        classNames=\"page-container\"\n        divClassName={\"seventh-page page\"}\n        handleEnter={() => {}}\n      >\n        <Page\n          leftButton\n          rightButton={false}\n          leftOnClick={() => setActivePage(\"sixth-page\")}\n          handleDismiss={props.handleDismiss}\n        >\n          <h1 className=\"big-title\">Have fun using this tool!</h1>\n          <div className=\"emoji-container\">\n            <span role=\"img\" aria-label=\"rat\" className=\"tutorial-emoji\">\n              \n            </span>\n            <span role=\"img\" aria-label=\"cheese\" className=\"tutorial-emoji\">\n              \n            </span>\n          </div>\n\n          <img\n            src={require(\"./imagesAndGifs/haveFunVisualizing.gif\")}\n            alt=\"Have fun!\"\n            className=\"gif gif-have-fun\"\n          ></img>\n        </Page>\n      </WrapperCSSTransition>\n    </div>\n  );\n};\n\ninterface PageProps {\n  leftButton: boolean;\n  rightButton: boolean;\n  leftOnClick?: () => void;\n  rightOnClick?: () => void;\n  handleDismiss: () => void;\n}\n\nconst Page: React.FC<PageProps> = (props) => {\n  return (\n    <div className=\"page\">\n      {props.children}\n      {props.leftButton && (\n        <button className=\"button button-prev\" onClick={props.leftOnClick}>\n          {\"<\"} Previous\n        </button>\n      )}\n      {props.rightButton && (\n        <button className=\"button button-next\" onClick={props.rightOnClick}>\n          Next {\">\"}\n        </button>\n      )}\n      <button className=\"button dismiss-button\" onClick={props.handleDismiss}>\n        Dismiss\n      </button>\n    </div>\n  );\n};\n","import React from \"react\";\nimport \"./NavBar.css\";\n\ninterface NavButtonProps {\n  text: string;\n  isVisualized: number;\n  className: string;\n  startClassName?: string;\n  visualizingClassName: string;\n  visualizedClassName: string;\n  handleClick: () => void;\n}\n\nexport const NavButton: React.FC<NavButtonProps> = (props) => {\n  const addedClassNames: string[] = [\n    props.startClassName ? props.startClassName : \"\",\n    props.visualizingClassName,\n    props.visualizedClassName,\n  ];\n\n  return (\n    <li\n      className={\n        \"nav-item \" +\n        addedClassNames[props.isVisualized] +\n        \" \" +\n        props.className\n      }\n      onClick={(e) => {\n        props.handleClick();\n      }}\n    >\n      <p>{props.text}</p>\n    </li>\n  );\n};\n","import React from \"react\";\nimport \"./NavBar.css\";\n\ninterface DropDownAlgoProps {\n  leftIcon?: string;\n  rightIcon?: string;\n  handleClick: () => void;\n}\n\nexport const DropDownItem: React.FC<DropDownAlgoProps> = (props) => {\n  return (\n    <div\n      className=\"menu-item\"\n      onClick={(e) => {\n        props.handleClick();\n      }}\n    >\n      {props.children}\n    </div>\n  );\n};\n","import React from \"react\";\nimport \"./NavBar.css\";\n\ninterface DropDownMenu {\n  height?: number;\n  left?: boolean;\n}\n\nexport const DropDownMenu: React.FC<DropDownMenu> = (props) => {\n  return (\n    <div\n      className={\"dropdown\" + (props.left ? \" left\" : \"\")}\n      style={{ height: props.height }}\n    >\n      {props.children}\n    </div>\n  );\n};\n","import React from \"react\";\nimport \"./NavBar.css\";\n\ninterface DropDownSliderProps {\n  minValue: number;\n  maxValue: number;\n  step: number;\n  defaultValue: number;\n  text: string;\n  handleChange: (event: any) => void;\n}\n\nexport const DropDownSlider: React.FC<DropDownSliderProps> = (props) => {\n  return (\n    <div className=\"slider-item\">\n      <div className=\"slider-item-text\">\n        <div>\n          <span>{props.text}</span>\n        </div>\n        <div className=\"slider-value\">\n          <span>{props.defaultValue}</span>\n        </div>\n      </div>\n      <input\n        className=\"slider\"\n        type=\"range\"\n        value={props.defaultValue}\n        min={props.minValue.toString()}\n        max={props.maxValue.toString()}\n        step={props.step}\n        onChange={(e) => props.handleChange(e.target.value)}\n      ></input>\n    </div>\n  );\n};\n","import React from \"react\";\nimport \"./NavBar.css\";\n\ninterface DropDownToggleSwitchProps {\n  text: string;\n  shouldShowWeights: boolean;\n  handleChange: () => void;\n}\n\nexport const DropDownToggleSwich: React.FC<DropDownToggleSwitchProps> = (\n  props\n) => {\n  return (\n    <div className=\"menu-item switch-item\">\n      <span className=\"switch-text\">{props.text}</span>\n      <label className=\"switch\">\n        <input\n          type=\"checkbox\"\n          checked={props.shouldShowWeights}\n          onChange={props.handleChange}\n        />\n        <span className=\"switch-slider round\"></span>\n      </label>\n    </div>\n  );\n};\n","import React, { useState } from \"react\";\nimport \"./NavBar.css\";\n\ninterface NavItemProps {\n  text: string;\n  id: string;\n  isVisualized: number;\n  shouldGreyOut: boolean;\n}\n\nexport const NavItem: React.FC<NavItemProps> = (props) => {\n  const [open, setOpen] = useState(false);\n\n  const handleClick: (e: any) => void = (event) => {\n    if (!props.shouldGreyOut || !props.isVisualized) setOpen(!open);\n    document.addEventListener(\"click\", (e) => {\n      const dropDownMenu = document.getElementById(props.id);\n      let targetElement = e.target as Element;\n\n      do {\n        if (targetElement === dropDownMenu) return;\n        targetElement = targetElement.parentNode as Element;\n      } while (targetElement);\n      setOpen(false);\n    });\n  };\n\n  return (\n    <li\n      id={props.id}\n      className={\n        \"nav-item\" +\n        (props.shouldGreyOut && props.isVisualized ? \" greyed-out\" : \"\")\n      }\n    >\n      <p className=\"icon-button\" onClick={handleClick}>\n        {props.text}\n      </p>\n      {open && props.children}\n    </li>\n  );\n};\n","import React from \"react\";\nimport \"./NavBar.css\";\n\ninterface NavSliderProps {\n  className: string;\n  minValue: number;\n  maxValue: number;\n  step: number;\n  defaultValue: number;\n  text: string;\n  handleChange: (event: any) => void;\n  isVisualized: number;\n  visualizingClassName: string;\n  visualizedClassName: string;\n}\n\nexport const NavSlider: React.FC<NavSliderProps> = (props) => {\n  return (\n    <li\n      className={\n        \"nav-slider nav-item \" +\n        props.className +\n        (props.isVisualized === 1 ? \" \" + props.visualizingClassName : \"\") +\n        (props.isVisualized === 2 ? \" \" + props.visualizedClassName : \"\")\n      }\n    >\n      <div className=\"nav-slider-item-text\">\n        <div>\n          <span>{props.text}</span>\n        </div>\n        <div className=\"nav-slider-value\">\n          <span>{props.defaultValue}</span>\n        </div>\n      </div>\n      <input\n        className=\"slider\"\n        type=\"range\"\n        value={props.defaultValue}\n        min={props.minValue.toString()}\n        max={props.maxValue.toString()}\n        step={props.step}\n        onChange={(e) => props.handleChange(e.target.value)}\n      ></input>\n    </li>\n  );\n};\n","import React from \"react\";\nimport \"./InfoButton.css\";\n\ninterface InfoButtonProps {\n  handleClick: () => void;\n  showTutorial: boolean;\n}\n\nexport const InfoButton: React.FC<InfoButtonProps> = (props) => {\n  return (\n    <div className=\"info\">\n      <button onClick={props.handleClick} className=\"info-button\">\n        i\n      </button>\n      <div>\n        <p className=\"info-tooltip\">\n          {props.showTutorial ? \"Hide\" : \"Show\"} tutorial\n        </p>\n      </div>\n    </div>\n  );\n};\n","import React from \"react\";\nimport \"./NavBar.css\";\n\ninterface EnergyCostProps {\n  distance: number;\n  showDistance: boolean;\n}\n\nexport const EnergyCost: React.FC<EnergyCostProps> = (props) => {\n  return (\n    <div\n      className={\n        \"distance \" + (props.showDistance ? \"show-distance\" : \"hide-distance\")\n      }\n    >\n      <span>The path's energy cost is {props.distance}</span>\n    </div>\n  );\n};\n","import React, { useEffect, useRef, useState } from \"react\";\nimport \"./Visualizer.css\";\nimport { Grid } from \"../Grid/Grid\";\nimport { NavBar } from \"../NavBar/NavBar\";\n\nimport { node } from \"../helperFunctions/usefulInterfaces\";\nimport {\n  singleTargetAlgorithms,\n  multipleTargetsAlgorithms,\n} from \"../helperFunctions/shortestPathAlgorithms/allAlgorithms\";\nimport { generateMazeGraph } from \"../helperFunctions/mazeGenerators/mazeGraph\";\nimport {\n  addPiecesOfCheese,\n  constructGrid,\n  reconstructGrid,\n} from \"../helperFunctions/constructGrid\";\nimport { WrapperCSSTransition } from \"../Wrapper/Wrapper\";\nimport { Tutorial } from \"../Tutorial/Tutorial\";\nimport { NavButton } from \"../NavBar/NavButton\";\nimport { DropDownItem } from \"../NavBar/DropDownAlgo\";\nimport { DropDownMenu } from \"../NavBar/DropDownMenu\";\nimport { DropDownSlider } from \"../NavBar/DropDownSlider\";\nimport { DropDownToggleSwich } from \"../NavBar/DropDownToggleSwitch\";\nimport { NavItem } from \"../NavBar/NavItem\";\nimport { NavSlider } from \"../NavBar/NavSlider\";\nimport { InfoButton } from \"../Tutorial/InfoButton\";\nimport { EnergyCost } from \"../NavBar/EnergyCost\";\n\nconst NUMBER_OF_COLUMNS: number = 28;\nconst NUMBER_OF_ROWS: number = 13;\nconst VISITED_ANIMATION_TIMEOUT: number = 35;\nconst PATH_ANIMATION_TIMEOUT: number = 125;\nconst FIRST_START_NODE: [number, number] = [6, 3];\nconst FIRST_END_NODE: [number, number] = [6, 24];\nconst FIRST_WALLS_DENSITY: number = 0.4;\nconst FIRST_MUD_DENSITY: number = 0.4;\nconst FIRST_MUD_WEIGHT: number = 4;\n// We define these constants out of the functional component\n// that the App uses to avoid re-running the functions to create\n// these each time there is a re-render\n\nconst [firstGrid, firstStartNode, firstTargetList] = constructGrid(\n  NUMBER_OF_COLUMNS,\n  NUMBER_OF_ROWS,\n  FIRST_START_NODE,\n  FIRST_END_NODE,\n  0\n);\n\nconst [firstpairGrid, mazeGraph] = generateMazeGraph(\n  NUMBER_OF_COLUMNS,\n  NUMBER_OF_ROWS,\n  firstGrid,\n  FIRST_WALLS_DENSITY,\n  FIRST_MUD_DENSITY,\n  FIRST_MUD_WEIGHT\n);\n\n// Component rendering everything in the webpage.\nconst Visualizer: React.FC = () => {\n  // State managing the tutorial of the project\n  const [showTutorial, setShowTutorial] = useState(true);\n\n  const gridRef = useRef(firstGrid);\n  // States managing the grid\n  const [grid, setGrid] = useState(firstGrid);\n  const [pairGrid, setPairGrid] = useState(firstpairGrid);\n  const [isVisualized, setIsVisualized] = useState(0);\n\n  // States managing the maze\n  const [maze, setMaze] = useState(mazeGraph);\n  const [wallsDensity, setWallsDensity] = useState(FIRST_WALLS_DENSITY);\n  const [mudDensity, setMudDensity] = useState(FIRST_MUD_DENSITY);\n  const [mudWeight, setMudWeight] = useState(FIRST_MUD_WEIGHT);\n  const [numberOfTargets, setNumberOfTargets] = useState(1);\n  const [shouldGenerateMaze, setShouldGenerateMaze] = useState(false);\n  const didMount = useRef(false);\n  const [showNumbers, setShowNumbers] = useState(true);\n\n  // States of the start and end nodes\n  const [startNode, setStartNode] = useState(firstStartNode);\n  const [targetList, setTargetList] = useState(firstTargetList);\n\n  // States managing the dropdown menu\n  const [algoActiveMenu, setAlgoActiveMenu] = useState(\"main-single-target\");\n  const [singleTargetAlgorithm, setSingleTargetAlgorithm] = useState(\n    \"Dijkstra's algorithm\"\n  );\n  const [multipleTargetsAlgorithm, setMultipleTargetsAlgorithm] = useState(\n    \"Nearest Neighbors Heuristic\"\n  );\n  const [showDistance, setShowDistance] = useState(false);\n  const [distance, setDistance] = useState(-1);\n\n  const [height, setHeight] = useState(undefined);\n\n  // State of the mouse\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\n  const draggedNode = useRef(startNode);\n\n  // This function is there to visualize the algorithm chosen in the drop down menu\n  const visualizeSingleTargetAlgorithm: (\n    visited: node[],\n    path: node[],\n    timeout: number\n  ) => number = (visited, path, timeout) => {\n    const n = visited.length;\n    for (let i: number = 0; i < n; i++) {\n      setTimeout(() => {\n        const newGrid: node[][] = gridRef.current.slice();\n        const node: node = visited[i];\n        // define the x and y of the current node\n        const x: number = node.x;\n        const y: number = node.y;\n        newGrid[x][y] = {\n          ...gridRef.current[x][y],\n          isVisited: true,\n        };\n        gridRef.current = newGrid;\n        setGrid(newGrid);\n      }, timeout + VISITED_ANIMATION_TIMEOUT * i);\n    }\n\n    const m = path.length;\n    for (let i: number = 0; i < m; i++) {\n      setTimeout(() => {\n        const newGrid: node[][] = gridRef.current.slice();\n        const successor: node = i < m - 1 ? path[i + 1] : path[i];\n        const node: node = path[i];\n        // define the x and y of the current node\n        const x: number = node.x;\n        const y: number = node.y;\n\n        newGrid[x][y] = {\n          ...gridRef.current[x][y],\n          isShortestPath: true,\n          isVisited: false,\n          successorPosition: getSuccessorPosition(node, successor),\n        };\n        gridRef.current = newGrid;\n        setGrid(newGrid);\n      }, timeout + VISITED_ANIMATION_TIMEOUT * n + PATH_ANIMATION_TIMEOUT * i + 500);\n    }\n    return timeout + VISITED_ANIMATION_TIMEOUT * n + PATH_ANIMATION_TIMEOUT * m;\n  };\n\n  // This function returns the position of the successor of a node in the shortest path\n  const getSuccessorPosition: (node: node, successor: node) => string = (\n    node,\n    successor\n  ) => {\n    if (node.x + 1 === successor.x) return \"D\";\n    if (node.y + 1 === successor.y) return \"R\";\n    if (node.x - 1 === successor.x) return \"U\";\n    if (node.y - 1 === successor.y) return \"L\";\n    return \"\";\n  };\n\n  // This function is there to visualize multipleTargetsAlgorithms\n  const visualizeMultipleTargetsAlgorithm: (\n    allVisitedAndPathsArray: [node[], node[]][]\n  ) => number = (allVisitedAndPathsArray) => {\n    let n: number = allVisitedAndPathsArray.length;\n    let currentTimeout: number = 0;\n    for (let i: number = 0; i < n; i++) {\n      const [visited, path] = allVisitedAndPathsArray[i];\n      currentTimeout = visualizeSingleTargetAlgorithm(\n        visited,\n        path,\n        currentTimeout\n      );\n\n      currentTimeout += visited.length > 0 ? 1250 : 0;\n      setTimeout(() => {\n        const newGrid: node[][] = gridRef.current.slice();\n        for (let x: number = 0; x < newGrid.length; x++) {\n          for (let y: number = 0; y < newGrid[0].length; y++) {\n            newGrid[x][y] = {\n              ...gridRef.current[x][y],\n              isVisited: false,\n            };\n          }\n        }\n        gridRef.current = newGrid;\n        setGrid(newGrid);\n      }, currentTimeout);\n      currentTimeout += 1000;\n    }\n    return currentTimeout - 1000;\n  };\n\n  // This function is passed to the drop down menu to handle the change of algorithm\n  const handleAlgorithmChange: (algorithmName: string) => () => void = (\n    algorithmName\n  ) => {\n    return () => {\n      numberOfTargets > 1\n        ? setMultipleTargetsAlgorithm(algorithmName)\n        : setSingleTargetAlgorithm(algorithmName);\n    };\n  };\n\n  // This function handles the click on the menu buttons\n  const handleMenuChange: (menuName: string) => () => void = (menuName) => {\n    return () => setAlgoActiveMenu(menuName);\n  };\n\n  // This function handles the logic of the visualization of the algorithms\n  const handleVisualization: () => void = () => {\n    if (isVisualized === 0) {\n      setIsVisualized(1);\n      if (numberOfTargets === 1) {\n        const [[visited, path], newDistance]: [\n          [node[], node[]],\n          number\n        ] = singleTargetAlgorithms[singleTargetAlgorithm](\n          grid,\n          pairGrid,\n          maze,\n          startNode,\n          targetList.map((targetNode) => grid[targetNode.x][targetNode.y])\n        );\n        const n: number = visited.length,\n          m: number = path.length;\n        visualizeSingleTargetAlgorithm(visited, path, 0);\n        setTimeout(() => {\n          setIsVisualized(2);\n          setDistance(newDistance);\n          setShowDistance(true);\n        }, VISITED_ANIMATION_TIMEOUT * n + PATH_ANIMATION_TIMEOUT * m + 500);\n        return;\n      }\n      const [allVisitedAndPaths, newDistance]: [\n        [node[], node[]][],\n        number\n      ] = multipleTargetsAlgorithms[multipleTargetsAlgorithm](\n        grid,\n        pairGrid,\n        maze,\n        startNode,\n        targetList.slice()\n      );\n      const timeout: number = visualizeMultipleTargetsAlgorithm(\n        allVisitedAndPaths\n      );\n      setTimeout(() => {\n        setIsVisualized(2);\n        setDistance(newDistance);\n        setShowDistance(true);\n      }, timeout);\n    }\n    if (isVisualized === 2) {\n      reinitializeGrid();\n      setShowDistance(false);\n    }\n  };\n\n  // This function calls the generate maze function\n  const generateMaze: () => void = () => {\n    if (isVisualized === 0) {\n      const [newPairGrid, newMaze] = generateMazeGraph(\n        NUMBER_OF_COLUMNS,\n        NUMBER_OF_ROWS,\n        grid,\n        wallsDensity,\n        mudDensity,\n        mudWeight\n      );\n      setPairGrid(newPairGrid);\n      setMaze(newMaze);\n      setShouldGenerateMaze(false);\n    }\n  };\n\n  // Reinitialize the the board\n  const reinitializeGrid: () => void = () => {\n    if (isVisualized !== 1) {\n      const [newGrid, newStartNode, newTargetList] = reconstructGrid(\n        NUMBER_OF_COLUMNS,\n        NUMBER_OF_ROWS,\n        [startNode.x, startNode.y],\n        targetList\n      );\n      for (let i: number = 0; i < newGrid.length; i++) {\n        for (let j: number = 0; j < newGrid[0].length; j++) {\n          gridRef.current[i][j] = newGrid[i][j];\n        }\n      }\n      gridRef.current = newGrid;\n      setGrid(newGrid);\n      setStartNode(newStartNode);\n      setTargetList(newTargetList);\n      setIsVisualized(0);\n    }\n  };\n\n  // toggles on and off the multiple targets\n  const toggleMultipleTargetGrid: () => void = () => {\n    if (isVisualized !== 1) {\n      let newGrid, newStartNode, newTargetList;\n      if (numberOfTargets > 1) {\n        [newGrid, newStartNode, newTargetList] = addPiecesOfCheese(\n          NUMBER_OF_COLUMNS,\n          NUMBER_OF_ROWS,\n          startNode,\n          targetList,\n          numberOfTargets - targetList.length\n        );\n        for (let i: number = 0; i < newGrid.length; i++) {\n          for (let j: number = 0; j < newGrid[0].length; j++) {\n            gridRef.current[i][j] = newGrid[i][j];\n          }\n        }\n      } else {\n        [newGrid, newStartNode, newTargetList] = constructGrid(\n          NUMBER_OF_COLUMNS,\n          NUMBER_OF_ROWS,\n          [startNode.x, startNode.y],\n          FIRST_END_NODE,\n          0\n        );\n      }\n      gridRef.current = newGrid;\n      setGrid(newGrid);\n      setStartNode(newStartNode);\n      setTargetList(newTargetList);\n      setIsVisualized(0);\n    }\n  };\n\n  // If the value of multipleTargets change, call the reinitialize function\n  useEffect(toggleMultipleTargetGrid, [numberOfTargets]);\n\n  // handle the change of the number of targets\n  const handleChangeNumberOfTargets: (val: number) => void = (val) => {\n    setNumberOfTargets(Math.floor(val));\n  };\n\n  // handle the click on the multiple targets button\n  const handleMultipleTargets: () => void = () => {\n    if (isVisualized === 0) {\n      setAlgoActiveMenu(\n        numberOfTargets > 1 ? \"main-single-target\" : \"main-multiple-target\"\n      );\n      setNumberOfTargets(numberOfTargets > 1 ? 1 : 5);\n    }\n  };\n\n  // Toggle the cheese or rat on the node\n  const toggleNode: (currentNode: node) => void = (currentNode) => {\n    let oldStartNode: node = startNode,\n      oldTargetList: node[] = targetList.slice();\n    if (draggedNode.current === startNode) {\n      oldStartNode = currentNode;\n    } else {\n      const isTargetNode: boolean = targetList.find(\n        (targetNode) => targetNode === currentNode\n      )\n        ? true\n        : false;\n      if (!isTargetNode) {\n        oldTargetList = oldTargetList.filter(\n          (targetNode) => targetNode !== draggedNode.current\n        );\n        oldTargetList.push(currentNode);\n      }\n    }\n    const [newGrid, newStartNode, newTargetList] = reconstructGrid(\n      NUMBER_OF_COLUMNS,\n      NUMBER_OF_ROWS,\n      [oldStartNode.x, oldStartNode.y],\n      oldTargetList\n    );\n    for (let x: number = 0; x < newGrid.length; x++) {\n      for (let y: number = 0; y < newGrid[0].length; y++) {\n        gridRef.current[x][y] = newGrid[x][y];\n      }\n    }\n    draggedNode.current = newGrid[currentNode.x][currentNode.y];\n    setStartNode(newStartNode);\n    setTargetList(newTargetList);\n    gridRef.current = newGrid;\n    setGrid(newGrid);\n  };\n\n  // handles the case when the mouse button is down\n  const handleMouseDown: (currentNode: node) => void = (currentNode) => {\n    const isTargetNode: boolean = targetList.find(\n      (targetNode) => targetNode === currentNode\n    )\n      ? true\n      : false;\n    if (isVisualized === 0 && (currentNode === startNode || isTargetNode)) {\n      setMouseIsPressed(true);\n      draggedNode.current = currentNode;\n    }\n  };\n\n  // handles the case whan the mouse button is down and you enter a node\n  const handleMouseEnter: (currentNode: node) => void = (currentNode) => {\n    if (mouseIsPressed) {\n      toggleNode(currentNode);\n    }\n  };\n\n  // handles the case when you mouse up\n  const handleMouseUp: () => void = () => {\n    setMouseIsPressed(false);\n  };\n\n  // function that returns the text in the visualization button\n  const getVisualizeText: () => string = () => {\n    if (isVisualized <= 0)\n      return (\n        \"Visualize \" +\n        (numberOfTargets > 1\n          ? multipleTargetsAlgorithm\n          : singleTargetAlgorithm) +\n        \"!\"\n      );\n    return \"Reinitialize Visualization\";\n  };\n\n  // updates the maze in real time\n  useEffect(() => {\n    if (didMount.current) setShouldGenerateMaze(true);\n    else didMount.current = true;\n  }, [wallsDensity, mudDensity, mudWeight]);\n\n  // Render the app\n  return (\n    <div className=\"App\" onMouseUp={() => handleMouseUp()}>\n      <NavBar>\n        <NavButton\n          text=\"Generate New Maze\"\n          isVisualized={isVisualized}\n          className={\n            \"generate-maze \" + (shouldGenerateMaze ? \"should-generate\" : \"\")\n          }\n          visualizingClassName=\"greyed-out\"\n          visualizedClassName=\"greyed-out\"\n          handleClick={generateMaze}\n        />\n        <NavItem\n          text=\"Maze options\"\n          id=\"maze-options\"\n          isVisualized={isVisualized}\n          shouldGreyOut={true}\n        >\n          <DropDownMenu left={true}>\n            <DropDownSlider\n              text=\"Density of walls:\"\n              minValue={0}\n              maxValue={1}\n              step={0.01}\n              defaultValue={wallsDensity}\n              handleChange={setWallsDensity}\n            ></DropDownSlider>\n            <DropDownSlider\n              text=\"Density of mud:\"\n              minValue={0}\n              maxValue={1}\n              step={0.01}\n              defaultValue={mudDensity}\n              handleChange={setMudDensity}\n            ></DropDownSlider>\n            <DropDownSlider\n              text=\"Mud Weight:\"\n              minValue={1.1}\n              maxValue={10}\n              step={0.1}\n              defaultValue={mudWeight}\n              handleChange={setMudWeight}\n            ></DropDownSlider>\n            <DropDownToggleSwich\n              text=\"Show Mud Weights ?\"\n              shouldShowWeights={showNumbers}\n              handleChange={() => setShowNumbers(!showNumbers)}\n            />\n          </DropDownMenu>\n        </NavItem>\n        <NavSlider\n          className={\n            numberOfTargets > 1 ? \"show-nav-slider\" : \"hide-nav-slider\"\n          }\n          text=\"Number of Targets:\"\n          minValue={2}\n          maxValue={10}\n          step={1}\n          defaultValue={numberOfTargets}\n          handleChange={handleChangeNumberOfTargets}\n          isVisualized={isVisualized}\n          visualizingClassName=\"greyed-out\"\n          visualizedClassName=\"greyed-out\"\n        />\n\n        <NavButton\n          text={\n            (numberOfTargets > 1 ? \"Disable\" : \"Enable\") + \" Multiple Targets\"\n          }\n          isVisualized={isVisualized}\n          className={\n            numberOfTargets > 1\n              ? \"disable-multiple-targets\"\n              : \"enable-multiple-targets\"\n          }\n          visualizingClassName=\"greyed-out\"\n          visualizedClassName=\"greyed-out\"\n          handleClick={handleMultipleTargets}\n        />\n        <EnergyCost distance={distance} showDistance={showDistance} />\n        <NavButton\n          text={getVisualizeText()}\n          isVisualized={isVisualized}\n          className=\"visualize-button\"\n          visualizingClassName=\"greyed-out highlight\"\n          visualizedClassName=\"highlight\"\n          handleClick={handleVisualization}\n        />\n        <NavItem\n          text=\"Algorithms\"\n          id=\"algorithms\"\n          isVisualized={isVisualized}\n          shouldGreyOut={false}\n        >\n          <DropDownMenu height={height}>\n            <WrapperCSSTransition\n              in={algoActiveMenu === \"main-single-target\"}\n              unmountOnExit\n              timeout={500}\n              classNames=\"menu-primary\"\n              divClassName=\"menu\"\n              handleEnter={setHeight}\n              appear\n            >\n              <DropDownItem handleClick={handleMenuChange(\"unweighted\")}>\n                <p>Algorithms for unweighted graphs</p>\n                <p className=\"arrow-right\">{\">\"}</p>\n              </DropDownItem>\n              <DropDownItem handleClick={handleMenuChange(\"weighted\")}>\n                <p>Algorithms for weighted graphs</p>\n                <p className=\"arrow-right\">{\">\"}</p>\n              </DropDownItem>\n            </WrapperCSSTransition>\n            <WrapperCSSTransition\n              in={algoActiveMenu === \"unweighted\"}\n              unmountOnExit\n              timeout={500}\n              classNames=\"menu-unweighted\"\n              divClassName=\"menu\"\n              handleEnter={setHeight}\n            >\n              <DropDownItem\n                handleClick={handleMenuChange(\"main-single-target\")}\n              >\n                <p className=\"arrow-left\">{\"<\"}</p>\n              </DropDownItem>\n              <DropDownItem\n                handleClick={handleAlgorithmChange(\"Depth First Search\")}\n              >\n                <p>Random Depth First Search</p>\n                {singleTargetAlgorithm === \"Depth First Search\" ? (\n                  <p className=\"tickmark\"></p>\n                ) : (\n                  \"\"\n                )}\n              </DropDownItem>\n              <DropDownItem\n                handleClick={handleAlgorithmChange(\"Breadth First Search\")}\n              >\n                <p>Breadth First Search</p>\n                {singleTargetAlgorithm === \"Breadth First Search\" ? (\n                  <p className=\"tickmark\"></p>\n                ) : (\n                  \"\"\n                )}\n              </DropDownItem>\n              <DropDownItem\n                handleClick={handleAlgorithmChange(\"Meet in the Middle BFS\")}\n              >\n                <p>Meet in the Middle BFS</p>\n                {singleTargetAlgorithm === \"Meet in the Middle BFS\" ? (\n                  <p className=\"tickmark\"></p>\n                ) : (\n                  \"\"\n                )}\n              </DropDownItem>\n            </WrapperCSSTransition>\n            <WrapperCSSTransition\n              in={algoActiveMenu === \"weighted\"}\n              unmountOnExit\n              timeout={500}\n              classNames=\"menu-weighted\"\n              divClassName=\"menu\"\n              handleEnter={setHeight}\n            >\n              <DropDownItem\n                handleClick={handleMenuChange(\"main-single-target\")}\n              >\n                <p className=\"arrow-left\">{\"<\"}</p>\n              </DropDownItem>\n              <DropDownItem\n                handleClick={handleAlgorithmChange(\"Dijkstra's algorithm\")}\n              >\n                <p>Dijkstra's Algorithm</p>\n                {singleTargetAlgorithm === \"Dijkstra's algorithm\" ? (\n                  <p className=\"tickmark\"></p>\n                ) : (\n                  \"\"\n                )}\n              </DropDownItem>\n              <DropDownItem handleClick={handleAlgorithmChange(\"A* algorithm\")}>\n                <p>A* Algorithm</p>\n                {singleTargetAlgorithm === \"A* algorithm\" ? (\n                  <p className=\"tickmark\"></p>\n                ) : (\n                  \"\"\n                )}\n              </DropDownItem>\n            </WrapperCSSTransition>\n            <WrapperCSSTransition\n              in={algoActiveMenu === \"main-multiple-target\"}\n              unmountOnExit\n              timeout={500}\n              classNames=\"menu-unweighted\"\n              divClassName=\"menu\"\n              handleEnter={setHeight}\n            >\n              <DropDownItem\n                handleClick={handleAlgorithmChange(\"Brute Force Algorithm\")}\n              >\n                <p>Brute Force Algorithm</p>\n                {multipleTargetsAlgorithm === \"Brute Force Algorithm\" ? (\n                  <p className=\"tickmark\"></p>\n                ) : (\n                  \"\"\n                )}\n              </DropDownItem>\n              <DropDownItem\n                handleClick={handleAlgorithmChange(\n                  \"Nearest Neighbors Heuristic\"\n                )}\n              >\n                <p>Nearest Neighbors Heuristic</p>\n                {multipleTargetsAlgorithm === \"Nearest Neighbors Heuristic\" ? (\n                  <p className=\"tickmark\"></p>\n                ) : (\n                  \"\"\n                )}\n              </DropDownItem>\n            </WrapperCSSTransition>\n          </DropDownMenu>\n        </NavItem>\n      </NavBar>\n\n      <Tutorial\n        handleDismiss={() => setShowTutorial(false)}\n        showTutorial={showTutorial}\n      />\n\n      <Grid\n        grid={grid}\n        pairGrid={pairGrid}\n        maze={maze}\n        mouseState={mouseIsPressed}\n        handleMouseDown={handleMouseDown}\n        handleMouseEnter={handleMouseEnter}\n        showNumbers={showNumbers}\n      >\n        <InfoButton\n          showTutorial={showTutorial}\n          handleClick={() => setShowTutorial(!showTutorial)}\n        />\n      </Grid>\n    </div>\n  );\n};\n\nexport default Visualizer;\n","import React from \"react\";\n\nimport { BrowserRouter as Router, Switch, Route } from \"react-router-dom\";\nimport Visualizer from \"./Visualizer/Visualizer\";\n\nconst App: React.FC = () => {\n  return (\n    <div>\n      <Router>\n        <Switch>\n          <Route exact path=\"/pathfinding-visualizer\" component={Visualizer} />\n          {/* <Route path=\"/react-rat\" component={ReactRat} /> */}\n        </Switch>\n      </Router>\n    </div>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\n// import PathFindingVisualizer from \"./Visualizer/PathFindingVisualizer\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}