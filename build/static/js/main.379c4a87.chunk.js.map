{"version":3,"sources":["GridNode/GridNode.tsx","Grid/Grid.tsx","NavBar/NavBar.tsx","helper_functions/binaryHeap.ts","helper_functions/shortestPathAlgorithms/dijkstra.ts","helper_functions/mazeGenerators/mazeGraph.ts","helper_functions/constructGrid.ts","Visualizer/Visualizer.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["GridNode","numberOfElementsPerRow","node","neighbors","className","addedClassName","i","length","neighbor","neighborX","neighborY","x","y","hasCheese","getAddedClassName","isStart","role","aria-label","isEnd","addEmoji","Grid","grid","maze","pairGrid","map","row","id","rowLength","key","index","ensure","get","argument","message","undefined","TypeError","NavBar","props","children","NavChangingButtonItem","isVisualized","visualizedClassName","onClick","e","handleClick","NavDropDownItem","useState","open","setOpen","shouldGreyOut","tabIndex","event","document","addEventListener","dropDownMenu","getElementById","targetElement","target","parentNode","text","DropDownMenu","activeMenu","left","CSSTransition","in","unmountOnExit","timeout","classNames","DropDownAlgo","changeAlgorithm","algorithmName","DropDownSlider","type","value","defaultValue","min","minValue","toString","max","maxValue","step","onChange","handleChangeWallsDensity","BinaryHeap","scoreFunction","content","this","element","push","bubbleUp","result","end","pop","sinkDown","n","score","parentN","Math","floor","parent","elemScore","child2N","child1N","swap","child1","child2","child2Score","dijkstraWithWalls","mazeGraph","startNode","endNode","m","distances","j","Number","MAX_SAFE_INTEGER","predecessor","fill","visited","pq","size","currentNode","currentX","currentY","nextNode","find","remove","currentDistance","shortestPath","retrieveShortestPath","current","unshift","createEmptyMazeGraph","columnLength","pairRow","Map","getNeighborsEmpty","set","generateMazeGraph","wallsDensity","createMazeGraph","currentWallsCount","stack","currentNonVisitedNeighbors","getNeighbors","neighborNode","random","maxWallsCount","randRow","getNeighborsII","randIndex","dir","includes","constructGrid","numberOfRow","numberOfColumn","currentRow","isVisited","isShortestPath","waitClassChange","firstGrid","firstStartNode","firstEndNode","firstpairGrid","Visualizer","setGrid","setMaze","setPairGrid","algorithm","setAlgorithm","setWallsDensity","setIsVisualized","setStartNode","setEndNode","visualizeAlgorithm","path","setTimeout","newGrid","slice","newNode","newStartNode","newEndNode","newPairGrid","newMaze","icon","App","exact","component","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console"],"mappings":"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","file":"static/js/main.379c4a87.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./GridNode.css\";\nimport { node } from \"../helper_functions/usefulInterfaces\";\n\ninterface Props {\n  numberOfElementsPerRow: number;\n  node: node;\n  neighbors: [number, number][];\n}\n\n// This component represents a single Node in the grid rendered in the DOM\nexport const GridNode: React.FC<Props> = ({\n  numberOfElementsPerRow,\n  node,\n  neighbors,\n}) => {\n  const getAddedClassName: () => string = () => {\n    let addedClassName: string = \"\";\n    for (let i = 0; i < neighbors.length; i++) {\n      let neighbor: [number, number] = neighbors[i];\n      let neighborX = neighbor[0];\n      let neighborY = neighbor[1];\n      if (neighborX === node.x + 1) addedClassName += \" no-wall-bottom\";\n      if (neighborX === node.x - 1) addedClassName += \" no-wall-top\";\n      if (neighborY === node.y + 1) addedClassName += \" no-wall-right\";\n      if (neighborY === node.y - 1) addedClassName += \" no-wall-left\";\n    }\n    if (node.hasCheese) addedClassName += \" cheese\";\n    return addedClassName;\n  };\n\n  const addEmoji: (node: node) => any = (node) => {\n    if (node.isStart) {\n      return (\n        <span role=\"img\" aria-label=\"rat\" className=\"content\">\n          üêÄ\n        </span>\n      );\n    }\n    if (node.isEnd) {\n      return (\n        <span role=\"img\" aria-label=\"rat\" className=\"content\">\n          üßÄ\n        </span>\n      );\n    }\n    return <span></span>;\n  };\n\n  return (\n    <div className={node.className + getAddedClassName()}>{addEmoji(node)}</div>\n  );\n};\n\n// const areEqual: (prevProps: Props, nextProps: Props) => boolean = (\n//   prevProps,\n//   nextProps\n// ) => {\n//   return prevProps.node.className === nextProps.node.className;\n// };\n\n// export const GridNode = React.memo(_GridNode, areEqual);\n","import React from \"react\";\nimport { GridNode } from \"../GridNode/GridNode\";\nimport \"./Grid.css\";\nimport { node } from \"../helper_functions/usefulInterfaces\";\n\ninterface Props {\n  grid: node[][];\n  maze: Map<[number, number], [number, number][]>;\n  pairGrid: [number, number][][];\n}\n\nexport const Grid: React.FC<Props> = ({ grid, maze, pairGrid }) => {\n  // Renders the grid in the DOM thanks to the grid state in the App component\n  return (\n    <div className=\"grid\">\n      {grid.map((row, id) => {\n        let rowLength = row.length;\n        return (\n          <div className=\"row\" key={id}>\n            {row.map((node, index) => (\n              <GridNode\n                numberOfElementsPerRow={rowLength}\n                key={id + index * rowLength}\n                node={node}\n                neighbors={ensure(maze.get(pairGrid[node.x][node.y]))}\n              ></GridNode>\n            ))}\n          </div>\n        );\n      })}\n    </div>\n  );\n};\n\n// This function is there to ensure that a value is not null or undefined\nfunction ensure<T>(\n  argument: T | undefined | null,\n  message: string = \"This value was promised to be there.\"\n): T {\n  if (argument === undefined || argument === null) {\n    throw new TypeError(message);\n  }\n\n  return argument;\n}\n","import React, { useState, useEffect, useRef } from \"react\";\nimport { CSSTransition } from \"react-transition-group\";\nimport \"./NavBar.css\";\n\nexport const NavBar: React.FC = (props) => {\n  return (\n    <nav className=\"navbar\">\n      <ul className=\"navbar-nav\">{props.children}</ul>\n    </nav>\n  );\n};\n\ninterface NavChangingButtonItemProps {\n  isVisualized: boolean;\n  className: string;\n  visualizedClassName: string;\n  handleClick: () => void;\n}\n\nexport const NavChangingButtonItem: React.FC<NavChangingButtonItemProps> = (\n  props\n) => {\n  return (\n    <li\n      className={\n        \"nav-item \" +\n        props.className +\n        (props.isVisualized ? \" \" + props.visualizedClassName : \"\")\n      }\n      onClick={(e) => {\n        props.handleClick();\n      }}\n    >\n      <p>{props.children}</p>\n    </li>\n  );\n};\n\ninterface NavDropDownItemProps {\n  tabIndex: number;\n  icon: string;\n  text: string;\n  id: string;\n  isVisualized: boolean;\n  shouldGreyOut: boolean;\n}\n\nexport const NavDropDownItem: React.FC<NavDropDownItemProps> = (props) => {\n  const [open, setOpen] = useState(false);\n  const handleBlur: (e: any) => void = (e) => {\n    setOpen(false);\n  };\n\n  const handleClick: (e: any) => void = (event) => {\n    if (!props.shouldGreyOut || !props.isVisualized) setOpen(!open);\n    document.addEventListener(\"click\", (e) => {\n      const dropDownMenu = document.getElementById(props.id);\n      let targetElement = e.target as Element;\n\n      do {\n        if (targetElement === dropDownMenu) return;\n        targetElement = targetElement.parentNode as Element;\n      } while (targetElement);\n      setOpen(false);\n    });\n  };\n\n  return (\n    <li\n      id={props.id}\n      className={\n        \"nav-item \" +\n        \" \" +\n        (props.shouldGreyOut && props.isVisualized ? \" greyed-out\" : \"\")\n      }\n      tabIndex={props.tabIndex}\n    >\n      <p className=\"icon-button\" onClick={handleClick}>\n        {props.text}\n      </p>\n      {open && props.children}\n    </li>\n  );\n};\n\ninterface DropDownMenu {\n  left: boolean;\n}\n\nexport const DropDownMenu: React.FC<DropDownMenu> = (props) => {\n  const [activeMenu, setActiveMenu] = useState(\"main\");\n  return (\n    <div className={\"dropdown\" + (props.left ? \" left\" : \" right\")}>\n      <CSSTransition\n        in={activeMenu === \"main\"}\n        unmountOnExit\n        timeout={100}\n        classNames=\"menu-primary\"\n      >\n        {props.children}\n      </CSSTransition>\n    </div>\n  );\n};\n\ninterface DropDownAlgoProps {\n  leftIcon?: string;\n  rightIcon?: string;\n  algorithmName: string;\n  changeAlgorithm: (algorithmName: string) => void;\n}\n\nexport const DropDownAlgo: React.FC<DropDownAlgoProps> = (props) => {\n  return (\n    <div\n      className=\"menu-item\"\n      onClick={(e) => {\n        props.changeAlgorithm(props.algorithmName);\n      }}\n    >\n      {props.children}\n    </div>\n  );\n};\n\ninterface DropDownSliderProps {\n  isVisualized: boolean;\n  minValue: number;\n  maxValue: number;\n  defaultValue: number;\n  text: string;\n  handleChangeWallsDensity: (event: any) => void;\n}\n\nexport const DropDownSlider: React.FC<DropDownSliderProps> = (props) => {\n  return (\n    <div className=\"slider-item\">\n      <div>\n        <p>{props.text}</p>\n      </div>\n      <input\n        className=\"slider\"\n        type=\"range\"\n        value={props.defaultValue}\n        min={props.minValue.toString()}\n        max={props.maxValue.toString()}\n        step={0.01}\n        onChange={(e) => props.handleChangeWallsDensity(e.target.value)}\n      ></input>\n    </div>\n  );\n};\n","export class BinaryHeap<T> {\n  content: (T | undefined)[];\n  scoreFunction: (x: T) => number;\n\n  constructor(scoreFunction: (x: T) => number) {\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n\n  push(element: T) {\n    this.content.push(element);\n    this.bubbleUp(this.content.length - 1);\n  }\n\n  pop(): T | undefined {\n    let result = this.content[0];\n    let end = this.content.pop();\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.sinkDown(0);\n    }\n    return result;\n  }\n\n  remove(node: T) {\n    let length = this.content.length;\n    // To remove a value, we must search through the array to find\n    // it.\n    for (var i = 0; i < length; i++) {\n      if (this.content[i] !== node) continue;\n      // When it is found, the process seen in 'pop' is repeated\n      // to fill up the hole.\n      let end = this.content.pop();\n      // If the element we popped was the one we needed to remove,\n      // we're done.\n      if (i === length - 1) break;\n      // Otherwise, we replace the removed element with the popped\n      // one, and allow it to float up or sink down as appropriate.\n      this.content[i] = end;\n      this.bubbleUp(i);\n      this.sinkDown(i);\n      break;\n    }\n  }\n\n  size() {\n    return this.content.length;\n  }\n\n  private bubbleUp(n: number) {\n    // Fetch the element that has to be moved.\n    let element = this.content[n],\n      score = this.scoreFunction(ensure(element));\n    // When at 0, an element can not go up any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      let parentN = Math.floor((n + 1) / 2) - 1,\n        parent = this.content[parentN];\n      // If the parent has a lesser score, things are in order and we\n      // are done.\n      if (score >= this.scoreFunction(ensure(parent))) break;\n\n      // Otherwise, swap the parent with the current element and\n      // continue.\n      this.content[parentN] = element;\n      this.content[n] = parent;\n      n = parentN;\n    }\n  }\n\n  private sinkDown(n: number) {\n    // Look up the target element and its score.\n    var length = this.content.length,\n      element = this.content[n],\n      elemScore = this.scoreFunction(ensure(element));\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) * 2,\n        child1N = child2N - 1;\n      // This is used to store the new position of the element,\n      // if any.\n      var swap = null;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N],\n          child1Score = this.scoreFunction(ensure(child1));\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore) swap = child1N;\n      }\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        var child2 = this.content[child2N],\n          child2Score = this.scoreFunction(ensure(child2));\n        if (child2Score < (swap == null ? elemScore : child2Score))\n          swap = child2N;\n      }\n\n      // No need to swap further, we are done.\n      if (swap == null) break;\n\n      // Otherwise, swap and continue.\n      this.content[n] = this.content[swap];\n      this.content[swap] = element;\n      n = swap;\n    }\n  }\n}\n\nfunction ensure<T>(\n  argument: T | undefined | null,\n  message: string = \"This value was promised to be there.\"\n): T {\n  if (argument === undefined || argument === null) {\n    throw new TypeError(message);\n  }\n\n  return argument;\n}\n","import { node } from \"../usefulInterfaces\";\nimport { BinaryHeap } from \"../binaryHeap\";\n\nexport const dijkstra: (\n  grid: node[][],\n  startNode: node,\n  targetNode: node\n) => [node[], node[]] = (grid, startNode, endNode) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the distances array\n  const distances: number[][] = [];\n  for (let i: number = 0; i < m; i++) {\n    distances.push([]);\n    for (let j: number = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  // Initialize the directions array we will use to perform Dijkstra's algorithm\n  const directions: number[][] = [\n    [0, 1],\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n  ];\n\n  //   Initialize the Binary Heap\n  let pq: BinaryHeap<node> = new BinaryHeap<node>(\n    (n: node) => distances[n.x][n.y]\n  );\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode: node = ensure(pq.pop());\n\n    // add the current node to the visited nodes\n    // currentNode.isVisited = true;\n    visited.push(currentNode);\n\n    // Get the coordinates of the nodes\n    let currentX: number = currentNode.x;\n    let currentY: number = currentNode.y;\n\n    // Iterate the neighbors of the node\n    for (const dir of directions) {\n      // Get the coordinates of the next node\n      let nextX: number = currentX + dir[0];\n      let nextY: number = currentY + dir[1];\n\n      // Check if the coordinates are valid\n      if (nextX >= 0 && nextX < m && nextY >= 0 && nextY < n) {\n        let nextNode: node = grid[nextX][nextY];\n\n        // If the node is not yet visited, remove it from the heap and\n        // put it back in with its new distance as the score function\n        if (!visited.find((currentNode) => currentNode === nextNode)) {\n          pq.remove(nextNode);\n          pq.push(nextNode);\n        }\n\n        // Calculate the distance between the current node and the next node\n        // To Do: take into account the weight of the path\n        let currentDistance: number = distances[currentX][currentY] + 1;\n\n        // If the distance is less than the distance in the array distances,\n        // change it and change the predecessor of the next node to be the current one\n        if (currentDistance < distances[nextX][nextY]) {\n          predecessor[nextNode.id] = currentNode;\n          distances[nextX][nextY] = currentDistance;\n        }\n\n        // If we found the target node then we return what we need\n        if (nextNode === endNode) {\n          // Retrieve the shortest path\n          const shortestPath = retrieveShortestPath(\n            predecessor,\n            startNode,\n            endNode\n          );\n          visited.shift();\n          // return the correct value\n          return [visited, shortestPath];\n        }\n      }\n    }\n  }\n\n  return [visited, []];\n};\n\nexport const dijkstraWithWalls: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [number, number][]>,\n  startNode: node,\n  targetNode: node\n) => [node[], node[]] = (grid, pairGrid, mazeGraph, startNode, endNode) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the distances array\n  const distances: number[][] = [];\n  for (let i: number = 0; i < m; i++) {\n    distances.push([]);\n    for (let j: number = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  //   Initialize the Binary Heap\n  let pq: BinaryHeap<node> = new BinaryHeap<node>(\n    (n: node) => distances[n.x][n.y]\n  );\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode: node = ensure(pq.pop());\n\n    // add the current node to the visited nodes\n    // currentNode.isVisited = true;\n    visited.push(currentNode);\n\n    // Get the coordinates of the nodes\n    let currentX: number = currentNode.x;\n    let currentY: number = currentNode.y;\n\n    // Iterate the neighbors of the node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentX][currentY])\n    )) {\n      // Check if the coordinates are valid\n      if (\n        neighbor[0] >= 0 &&\n        neighbor[0] < m &&\n        neighbor[1] >= 0 &&\n        neighbor[1] < n\n      ) {\n        let nextNode: node = grid[neighbor[0]][neighbor[1]];\n\n        // If the node is not yet visited, remove it from the heap and\n        // put it back in with its new distance as the score function\n        if (!visited.find((currentNode) => currentNode === nextNode)) {\n          pq.remove(nextNode);\n          pq.push(nextNode);\n        }\n\n        // Calculate the distance between the current node and the next node\n        // To Do: take into account the weight of the path\n        let currentDistance: number = distances[currentX][currentY] + 1;\n\n        // If the distance is less than the distance in the array distances,\n        // change it and change the predecessor of the next node to be the current one\n        if (currentDistance < distances[neighbor[0]][neighbor[1]]) {\n          predecessor[nextNode.id] = currentNode;\n          distances[neighbor[0]][neighbor[1]] = currentDistance;\n        }\n\n        // If we found the target node then we return what we need\n        if (nextNode === endNode) {\n          // Retrieve the shortest path\n          const shortestPath = retrieveShortestPath(\n            predecessor,\n            startNode,\n            endNode\n          );\n          visited.push(endNode);\n          return [visited, shortestPath];\n        }\n      }\n    }\n  }\n\n  return [visited, []];\n};\n\n// This function retrieves the shortest path from the predecessor array from Dijkstra's algorithm\nconst retrieveShortestPath: (\n  predecessor: node[],\n  startNode: node,\n  endNode: node\n) => node[] = (predecessor, startNode, endNode) => {\n  let shortestPath = [endNode];\n  let current = endNode;\n  while (current !== startNode) {\n    current = predecessor[current.id];\n    shortestPath.unshift(current);\n  }\n\n  return shortestPath;\n};\n\n// This function is here to ensure that a value is not undefined (especially when using arrays).\nfunction ensure<T>(\n  argument: T | undefined | null,\n  message: string = \"This value was promised to be there.\"\n): T {\n  if (argument === undefined || argument === null) {\n    throw new TypeError(message);\n  }\n\n  return argument;\n}\n","import { node } from \"../usefulInterfaces\";\n\n// TODO: Refactor the code to use the different key-values pair as the nodes get changed when there is a setGrid that is applied\n\nconst createMazeGraph: (\n  rowLength: number,\n  columnLength: number,\n  grid: node[][]\n) => [[number, number][][], Map<[number, number], [number, number][]>] = (\n  rowLength,\n  columnLength,\n  grid\n) => {\n  let pairGrid: [number, number][][] = [];\n  for (let i: number = 0; i < columnLength; i++) {\n    let pairRow: [number, number][] = [];\n    for (let j: number = 0; j < rowLength; j++) {\n      let currentNode: node = grid[i][j];\n      pairRow.push([currentNode.x, currentNode.y]);\n    }\n    pairGrid.push(pairRow);\n  }\n\n  // Create the maze graph\n  let mazeGraph: Map<[number, number], [number, number][]> = new Map();\n  for (let i: number = 0; i < columnLength; i++) {\n    for (let j: number = 0; j < rowLength; j++) {\n      mazeGraph.set(pairGrid[i][j], []);\n    }\n  }\n  return [pairGrid, mazeGraph];\n};\n\nexport const createEmptyMazeGraph: (\n  rowLength: number,\n  columnLength: number,\n  grid: node[][]\n) => [[number, number][][], Map<[number, number], [number, number][]>] = (\n  rowLength,\n  columnLength,\n  grid\n) => {\n  let pairGrid: [number, number][][] = [];\n  for (let i: number = 0; i < columnLength; i++) {\n    let pairRow: [number, number][] = [];\n    for (let j: number = 0; j < rowLength; j++) {\n      let currentNode: node = grid[i][j];\n      pairRow.push([currentNode.x, currentNode.y]);\n    }\n    pairGrid.push(pairRow);\n  }\n  // Create the maze graph\n  let mazeGraph: Map<[number, number], [number, number][]> = new Map();\n  for (let i: number = 0; i < columnLength; i++) {\n    for (let j: number = 0; j < rowLength; j++) {\n      let neighbors: [number, number][] = getNeighborsEmpty(\n        pairGrid,\n        [i, j],\n        columnLength,\n        rowLength\n      );\n      mazeGraph.set(pairGrid[i][j], neighbors);\n    }\n  }\n  return [pairGrid, mazeGraph];\n};\n\nexport const generateMazeGraph: (\n  rowLength: number,\n  columnLength: number,\n  grid: node[][],\n  wallsDensity: number\n) => [[number, number][][], Map<[number, number], [number, number][]>] = (\n  rowLength,\n  columnLength,\n  grid,\n  wallsDensity\n) => {\n  let [pairGrid, mazeGraph] = createMazeGraph(rowLength, columnLength, grid);\n\n  // I. Generate a maze where each cells is reachable (with a DFS)\n  let currentWallsCount: number =\n    2 * (rowLength - 1) * (columnLength - 1) + rowLength + columnLength - 2;\n\n  // 1. Choose the initial cell, mark it as visited and push it to the stack\n  let startNode: [number, number] = pairGrid[0][0];\n  let stack: [number, number][] = [startNode];\n  let visited: [number, number][] = [startNode];\n\n  // 2. While the stack is not empty\n  while (stack.length > 0) {\n    // 1. Pop a cell from the stack and make it a current cell\n    let currentNode: [number, number] = ensure(stack.pop());\n    let currentNonVisitedNeighbors: [number, number][] = getNeighbors(\n      pairGrid,\n      currentNode,\n      rowLength,\n      columnLength,\n      visited\n    );\n    // 2. If the current cell has any neighbours which have not been visited\n    if (currentNonVisitedNeighbors.length > 0) {\n      // 1. Push the current cell to the stack\n      stack.push(currentNode);\n\n      // 2. Choose one of the unvisited neighbours\n      let randIndex: number = Math.floor(\n        Math.random() * currentNonVisitedNeighbors.length\n      );\n      let neighborNode: [number, number] =\n        currentNonVisitedNeighbors[randIndex];\n\n      // 3. Remove the wall between the current cell and the chosen cell\n      let currentNodeNeighbors: [number, number][] = ensure(\n        mazeGraph.get(currentNode)\n      );\n      currentNodeNeighbors.push(neighborNode);\n      // mazeGraph.set(currentNode, currentNodeNeighbors);\n\n      let neighborNodeNeighbors: [number, number][] = ensure(\n        mazeGraph.get(neighborNode)\n      );\n      neighborNodeNeighbors.push(currentNode);\n      // mazeGraph.set(neighborNode, neighborNodeNeighbors);\n\n      // 4. Mark the chosen cell as visited and push it to the stack\n      visited.push(neighborNode);\n      stack.push(neighborNode);\n\n      // 5. Remove 1 from the currentWallsCount\n      currentWallsCount--;\n    }\n  }\n\n  let maxWallsCount: number = currentWallsCount;\n  // II. Remove walls until the desired density is achieved\n  while (currentWallsCount * (1 / maxWallsCount) > wallsDensity) {\n    // 1. Choosse a node randomly\n    let randRow: number = Math.floor(Math.random() * rowLength);\n    let randCol: number = Math.floor(Math.random() * columnLength);\n    let currentNode: [number, number] = pairGrid[randCol][randRow];\n\n    // 2. Get the cells with a wall with the current cell\n    let neighbors: [number, number][] = getNeighborsII(\n      pairGrid,\n      currentNode,\n      rowLength,\n      columnLength,\n      mazeGraph\n    );\n\n    if (neighbors.length > 0) {\n      // 3. Choose one of the cells with a wall\n      let randIndex: number = Math.floor(Math.random() * neighbors.length);\n      let neighborNode: [number, number] =\n        pairGrid[neighbors[randIndex][0]][neighbors[randIndex][1]];\n\n      // 4. Remove the wall between the 2 cells\n      let currentNodeNeighbors: [number, number][] = ensure(\n        mazeGraph.get(currentNode)\n      );\n      currentNodeNeighbors.push(neighborNode);\n      // mazeGraph.set(currentNode, currentNodeNeighbors);\n\n      let neighborNodeNeighbors: [number, number][] = ensure(\n        mazeGraph.get(neighborNode)\n      );\n      neighborNodeNeighbors.push(currentNode);\n      // mazeGraph.set(neighborNode, neighborNodeNeighbors);\n\n      currentWallsCount--;\n    }\n  }\n  return [pairGrid, mazeGraph];\n};\n\nconst getNeighbors: (\n  grid: [number, number][][],\n  currentNode: [number, number],\n  rowLength: number,\n  columnLength: number,\n  visited: [number, number][]\n) => [number, number][] = (\n  pairGrid,\n  currentNode,\n  rowLength,\n  columnLength,\n  visited\n) => {\n  const directions = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n\n  let neighbors: [number, number][] = [];\n  let neighborX: number = -1;\n  let neighborY: number = -1;\n\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n    if (\n      neighborX >= 0 &&\n      neighborX < columnLength &&\n      neighborY >= 0 &&\n      neighborY < rowLength &&\n      !visited.includes(pairGrid[neighborX][neighborY])\n    ) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n  return neighbors;\n};\n\nexport const getNeighborsEmpty: (\n  pairGrid: [number, number][][],\n  currentNode: [number, number],\n  columnLength: number,\n  rowLength: number\n) => [number, number][] = (pairGrid, currentNode, columnLength, rowLength) => {\n  const directions = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n\n  let neighbors: [number, number][] = [];\n  let neighborX: number = -1;\n  let neighborY: number = -1;\n\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n    if (\n      neighborX >= 0 &&\n      neighborX < columnLength &&\n      neighborY >= 0 &&\n      neighborY < rowLength\n    ) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n  return neighbors;\n};\n\nconst getNeighborsII: (\n  pairGrid: [number, number][][],\n  currentNode: [number, number],\n  rowLength: number,\n  columnLength: number,\n  mazeGraph: Map<[number, number], [number, number][]>\n) => [number, number][] = (\n  pairGrid,\n  currentNode,\n  rowLength,\n  columnLength,\n  mazeGraph\n) => {\n  const directions = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n\n  let neighbors: [number, number][] = [];\n  let neighborX: number = -1;\n  let neighborY: number = -1;\n\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n    if (\n      neighborX >= 0 &&\n      neighborX < columnLength &&\n      neighborY >= 0 &&\n      neighborY < rowLength &&\n      !mazeGraph.get(currentNode)?.includes(pairGrid[neighborX][neighborY])\n    ) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n  return neighbors;\n};\n\nfunction ensure<T>(\n  argument: T | undefined | null,\n  message: string = \"This value was promised to be there.\"\n): T {\n  if (argument === undefined || argument === null) {\n    throw new TypeError(message);\n  }\n\n  return argument;\n}\n","import { node } from \"./usefulInterfaces\";\n\n// This function (Not a React Component!) is made to initialize the grid rendered in the App component.\nexport const constructGrid: (\n  numberOfRows: number,\n  numberOfColumn: number,\n  startNode: [number, number],\n  endNode: [number, number]\n) => [node[][], node, node] = (\n  numberOfRow,\n  numberOfColumn,\n  startNode,\n  endNode\n) => {\n  let result: node[][] = [];\n  for (let i: number = 0; i < numberOfColumn; i++) {\n    let currentRow: node[] = [];\n    for (let j: number = 0; j < numberOfRow; j++) {\n      let currentNode = {\n        id: i + j * numberOfColumn,\n        x: i,\n        y: j,\n        isStart: false,\n        isEnd: false,\n        isVisited: false,\n        isShortestPath: false,\n        waitClassChange: 0,\n        className: \"grid-node\",\n        hasCheese: false,\n      };\n      currentRow.push(currentNode);\n    }\n    result.push(currentRow);\n  }\n  result[startNode[0]][startNode[1]] = {\n    ...result[startNode[0]][startNode[1]],\n    isStart: true,\n    className: \"grid-node start-node\",\n  };\n  result[endNode[0]][endNode[1]] = {\n    ...result[endNode[0]][endNode[1]],\n    isEnd: true,\n    className: \"grid-node end-node\",\n  };\n  // result = piecesOfCheese(result, numberOfColumn, numberOfRow, 21);\n  return [\n    result,\n    result[startNode[0]][startNode[1]],\n    result[endNode[0]][endNode[1]],\n  ];\n};\n\nconst piecesOfCheese: (\n  grid: node[][],\n  m: number,\n  n: number,\n  cheeseNum: number\n) => node[][] = (grid, m, n, cheeseNum) => {\n  let visited: boolean[][] = new Array(n);\n  for (let i: number = 0; i < n; ++i) {\n    visited[i] = new Array(n);\n  }\n  for (let i: number = 0; i < n; ++i) {\n    for (let j: number = 0; j < n; ++j) {\n      visited[i][j] = false;\n    }\n  }\n\n  visited[0][0] = true;\n  visited[n - 1][n - 1] = true;\n  for (let k: number = 0; k < cheeseNum / 2; k++) {\n    let i = -1,\n      j = -1;\n    do {\n      i = Math.floor(Math.random() * n);\n      j = Math.floor(Math.random() * n);\n    } while (visited[i][j]);\n    visited[i][j] = true;\n    visited[n - 1 - i][n - 1 - j] = true;\n    grid[i][j].hasCheese = true;\n    grid[n - 1 - i][n - 1 - j].hasCheese = true;\n  }\n  grid[Math.floor(n / 2)][Math.floor(n / 2)].hasCheese = true;\n  return grid;\n};\n","import React, { useState, useEffect } from \"react\";\nimport \"./Visualizer.css\";\nimport { Grid } from \"../Grid/Grid\";\nimport {\n  NavBar,\n  NavDropDownItem,\n  DropDownMenu,\n  DropDownAlgo,\n  DropDownSlider,\n  NavChangingButtonItem,\n} from \"../NavBar/NavBar\";\nimport { SecondaryHeader } from \"../SecondaryHeader/SecondaryHeader\";\nimport { node } from \"../helper_functions/usefulInterfaces\";\nimport {\n  dijkstra,\n  dijkstraWithWalls,\n} from \"../helper_functions/shortestPathAlgorithms/dijkstra\";\nimport {\n  createEmptyMazeGraph,\n  generateMazeGraph,\n} from \"../helper_functions/mazeGenerators/mazeGraph\";\nimport { constructGrid } from \"../helper_functions/constructGrid\";\n\nconst NUMBER_OF_ROWS: number = 28;\nconst NUMBER_OF_COLUMN: number = 13;\n\n// We define these constants out of the functional component\n// that the App uses to avoid re-running the functions to create\n// these each time there is a re-render\nconst [firstGrid, firstStartNode, firstEndNode] = constructGrid(\n  NUMBER_OF_ROWS,\n  NUMBER_OF_COLUMN,\n  [6, 3],\n  [6, 24]\n);\n\nconst [firstpairGrid, mazeGraph] = createEmptyMazeGraph(\n  NUMBER_OF_ROWS,\n  NUMBER_OF_COLUMN,\n  firstGrid\n);\n\n// Component rendering everything in the webpage.\nconst Visualizer: React.FC = () => {\n  // States managing the grid\n  const [grid, setGrid] = useState(firstGrid);\n  const [maze, setMaze] = useState(mazeGraph);\n  const [pairGrid, setPairGrid] = useState(firstpairGrid);\n  const [algorithm, setAlgorithm] = useState(\"dijkstraWithWalls\");\n  const [wallsDensity, setWallsDensity] = useState(0.7);\n  const [isVisualized, setIsVisualized] = useState(false);\n  // const [mouseIsPressed, setMouseIsPressed] = useState(false);\n\n  // States of the start and end node\n  const [startNode, setStartNode] = useState(firstStartNode);\n  const [endNode, setEndNode] = useState(firstEndNode);\n\n  // This function is there to visualize the algorithm chosen in the drop down menu\n  const visualizeAlgorithm: (visited: node[], path: node[]) => void = (\n    visited,\n    path\n  ) => {\n    const n = visited.length;\n    for (let i: number = 0; i < n; i++) {\n      setTimeout(() => {\n        const newGrid = grid.slice();\n        const node = visited[i];\n        // define the x and y of the current node\n        const x: number = node.x;\n        const y: number = node.y;\n        const newNode = {\n          ...node,\n          isVisited: true,\n          className: \"grid-node visited-node\",\n          waitClassChange: 0,\n        };\n        newGrid[x][y] = newNode;\n        setGrid(newGrid);\n      }, 30 * i);\n    }\n\n    const m = path.length;\n    for (let i: number = 0; i < m; i++) {\n      setTimeout(() => {\n        const newGrid = grid.slice();\n        const node = path[i];\n        // define the x and y of the current node\n        const x: number = node.x;\n        const y: number = node.y;\n        const newNode = {\n          ...node,\n          isShortestPath: true,\n          className: \"grid-node shortest-path-node\",\n          waitClassChange: 0,\n        };\n        newGrid[x][y] = newNode;\n        setGrid(newGrid);\n      }, 30 * n + 150 * i);\n    }\n  };\n\n  // This function is passed to the drop down menu to handle the change of algorithm\n  const handleAlgorithmChange: (algorithmName: string) => void = (\n    algorithmName\n  ) => {\n    setAlgorithm(algorithmName);\n  };\n\n  // This function changes the algorithm that will be run, at the moment only dijkstra is implemented\n  const chooseAlgorithm: (\n    algorithmName: string\n  ) => (\n    grid: node[][],\n    pairGrid: [number, number][][],\n    mazeGraph: Map<[number, number], [number, number][]>,\n    startNode: node,\n    endNode: node\n  ) => [node[], node[]] = (algorithmName) => {\n    if (algorithmName === \"dijkstraWithWalls\") {\n      return dijkstraWithWalls;\n    }\n    return dijkstraWithWalls;\n  };\n\n  // This function calls the generate maze function\n  const generateMaze: () => void = () => {\n    const newGrid = grid.slice();\n    const [newPairGrid, newMaze] = generateMazeGraph(\n      NUMBER_OF_ROWS,\n      NUMBER_OF_COLUMN,\n      newGrid,\n      wallsDensity\n    );\n    setGrid(newGrid);\n    setPairGrid(newPairGrid);\n    setMaze(newMaze);\n  };\n\n  // Reinitialize the the board\n  const reinitialize: () => void = () => {\n    const [newGrid, newStartNode, newEndNode] = constructGrid(\n      NUMBER_OF_ROWS,\n      NUMBER_OF_COLUMN,\n      [startNode.x, startNode.y],\n      [endNode.x, endNode.y]\n    );\n    const [newPairGrid, newMaze] = createEmptyMazeGraph(\n      NUMBER_OF_ROWS,\n      NUMBER_OF_COLUMN,\n      newGrid\n    );\n    setGrid(newGrid);\n    setPairGrid(newPairGrid);\n    setMaze(newMaze);\n    setStartNode(newStartNode);\n    setEndNode(newEndNode);\n    setIsVisualized(false);\n  };\n\n  // The following block of functions handles the making of walls in the grid\n  // This feature is currently not used as it is not a good fit with the current direction of the app\n\n  // const toggleWall: (x: number, y: number) => void = (x, y) => {\n  //   const newGrid: node[][] = grid.slice();\n  //   let newNode;\n  //   if (!newGrid[x][y].isWall) {\n  //     newNode = {\n  //       ...newGrid[x][y],\n  //       isWall: !newGrid[x][y].isWall,\n  //       className: \"grid-node wall-node\",\n  //     };\n  //   } else {\n  //     newNode = {\n  //       ...newGrid[x][y],\n  //       isWall: !newGrid[x][y].isWall,\n  //       className: \"grid-node\",\n  //     };\n  //   }\n  //   newGrid[x][y] = newNode;\n  //   setGrid(newGrid);\n  // };\n\n  // // handles the case when the mouse button is down\n  // const handleMouseDown: (x: number, y: number) => void = (x, y) => {\n  //   toggleWall(x, y);\n  //   setMouseIsPressed(false);\n  // };\n\n  // // handles the case whan the mouse button is down and you enter a node\n  // const handleMouseEnter: (x: number, y: number) => void = (x, y) => {\n  //   if (mouseIsPressed) {\n  //     toggleWall(x, y);\n  //   }\n  // };\n\n  // // handles the case when you mouse up\n  // const handleMouseUp: () => void = () => {\n  //   setMouseIsPressed(false);\n  // };\n\n  // Render the app\n  return (\n    <div className=\"App\">\n      <NavBar>\n        <NavChangingButtonItem\n          isVisualized={isVisualized}\n          className=\"reinitialize\"\n          visualizedClassName=\"highlight\"\n          handleClick={reinitialize}\n        >\n          Reinitialize\n        </NavChangingButtonItem>\n        <NavChangingButtonItem\n          isVisualized={isVisualized}\n          className=\"generate-maze\"\n          visualizedClassName=\"greyed-out\"\n          handleClick={generateMaze}\n        >\n          Generate maze\n        </NavChangingButtonItem>\n        <NavDropDownItem\n          tabIndex={1}\n          icon=\"\"\n          text=\"Maze options\"\n          id=\"maze-options\"\n          isVisualized={isVisualized}\n          shouldGreyOut={true}\n        >\n          <DropDownMenu left={false}>\n            <DropDownSlider\n              isVisualized={isVisualized}\n              minValue={0.1}\n              maxValue={1}\n              defaultValue={wallsDensity}\n              text=\"Density of walls\"\n              handleChangeWallsDensity={setWallsDensity}\n            ></DropDownSlider>\n          </DropDownMenu>\n        </NavDropDownItem>\n        <NavChangingButtonItem\n          isVisualized={isVisualized}\n          className=\"visualize-button\"\n          visualizedClassName=\"greyed-out\"\n          handleClick={() => {\n            if (!isVisualized) {\n              visualizeAlgorithm(\n                ...chooseAlgorithm(algorithm)(\n                  grid,\n                  pairGrid,\n                  maze,\n                  startNode,\n                  endNode\n                )\n              );\n              setIsVisualized(true);\n            }\n          }}\n        >\n          Visualize!\n        </NavChangingButtonItem>\n        <NavDropDownItem\n          tabIndex={2}\n          icon=\"&#12851;\"\n          text=\"Algorithm\"\n          id=\"algorithms\"\n          isVisualized={isVisualized}\n          shouldGreyOut={false}\n        >\n          <DropDownMenu left={true}>\n            <DropDownAlgo\n              changeAlgorithm={handleAlgorithmChange}\n              algorithmName=\"dijkstraWithWalls\"\n            >\n              <p>Dijkstra's Algorithm</p>\n              {algorithm === \"dijkstraWithWalls\" ? <p>‚úì</p> : \"\"}\n            </DropDownAlgo>\n            {/* <DropDownAlgo\n              changeAlgorithm={handleAlgorithmChange}\n              algorithmName=\"A*\"\n            >\n              A* Algorithm\n            </DropDownAlgo> */}\n          </DropDownMenu>\n        </NavDropDownItem>\n      </NavBar>\n      {/* <SecondaryHeader>\n        <button\n          className=\"visualize-button\"\n          onClick={(e) => {\n            visualizeAlgorithm(\n              ...chooseAlgorithm(algorithm)(\n                grid,\n                pairGrid,\n                mazeGraph,\n                startNode,\n                endNode\n              )\n            );\n          }}\n        >\n          Visualize the path!\n        </button>\n      </SecondaryHeader> */}\n      <Grid grid={grid} pairGrid={pairGrid} maze={maze} />\n    </div>\n  );\n};\n\nexport default Visualizer;\n","import React from \"react\";\nimport { BrowserRouter as Router, Switch, Route } from \"react-router-dom\";\nimport Visualizer from \"./Visualizer/Visualizer\";\n\nconst App: React.FC = () => {\n  return (\n    <div>\n      <Router>\n        <Switch>\n          <Route exact path=\"/pathfinding-visualizer\" component={Visualizer} />\n          {/* <Route path=\"/react-rat\" component={ReactRat} /> */}\n        </Switch>\n      </Router>\n    </div>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\n// import PathFindingVisualizer from \"./Visualizer/PathFindingVisualizer\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}